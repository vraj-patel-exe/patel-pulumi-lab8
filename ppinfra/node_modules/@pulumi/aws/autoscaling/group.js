"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.Group = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides an Auto Scaling Group resource.
 *
 * > **Note:** You must specify either `launchConfiguration`, `launchTemplate`, or `mixedInstancesPolicy`.
 *
 * > **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Pulumi provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `loadBalancers`, `targetGroupArns` and `trafficSource` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const test = new aws.ec2.PlacementGroup("test", {
 *     name: "test",
 *     strategy: aws.ec2.PlacementStrategy.Cluster,
 * });
 * const bar = new aws.autoscaling.Group("bar", {
 *     name: "foobar3-test",
 *     maxSize: 5,
 *     minSize: 2,
 *     healthCheckGracePeriod: 300,
 *     healthCheckType: "ELB",
 *     desiredCapacity: 4,
 *     forceDelete: true,
 *     placementGroup: test.id,
 *     launchConfiguration: foobar.name,
 *     vpcZoneIdentifiers: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     instanceMaintenancePolicy: {
 *         minHealthyPercentage: 90,
 *         maxHealthyPercentage: 120,
 *     },
 *     initialLifecycleHooks: [{
 *         name: "foobar",
 *         defaultResult: "CONTINUE",
 *         heartbeatTimeout: 2000,
 *         lifecycleTransition: "autoscaling:EC2_INSTANCE_LAUNCHING",
 *         notificationMetadata: JSON.stringify({
 *             foo: "bar",
 *         }),
 *         notificationTargetArn: "arn:aws:sqs:us-east-1:444455556666:queue1*",
 *         roleArn: "arn:aws:iam::123456789012:role/S3Access",
 *     }],
 *     tags: [
 *         {
 *             key: "foo",
 *             value: "bar",
 *             propagateAtLaunch: true,
 *         },
 *         {
 *             key: "lorem",
 *             value: "ipsum",
 *             propagateAtLaunch: false,
 *         },
 *     ],
 * });
 * ```
 *
 * ### With Latest Version Of Launch Template
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const foobar = new aws.ec2.LaunchTemplate("foobar", {
 *     namePrefix: "foobar",
 *     imageId: "ami-1a2b3c",
 *     instanceType: "t2.micro",
 * });
 * const bar = new aws.autoscaling.Group("bar", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 1,
 *     minSize: 1,
 *     launchTemplate: {
 *         id: foobar.id,
 *         version: "$Latest",
 *     },
 * });
 * ```
 *
 * ### Mixed Instances Policy
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.LaunchTemplate("example", {
 *     namePrefix: "example",
 *     imageId: exampleAwsAmi.id,
 *     instanceType: "c5.large",
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 1,
 *     minSize: 1,
 *     mixedInstancesPolicy: {
 *         launchTemplate: {
 *             launchTemplateSpecification: {
 *                 launchTemplateId: example.id,
 *             },
 *             overrides: [
 *                 {
 *                     instanceType: "c4.large",
 *                     weightedCapacity: "3",
 *                 },
 *                 {
 *                     instanceType: "c3.large",
 *                     weightedCapacity: "2",
 *                 },
 *             ],
 *         },
 *     },
 * });
 * ```
 *
 * ### Mixed Instances Policy with Spot Instances and Capacity Rebalance
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.LaunchTemplate("example", {
 *     namePrefix: "example",
 *     imageId: exampleAwsAmi.id,
 *     instanceType: "c5.large",
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     capacityRebalance: true,
 *     desiredCapacity: 12,
 *     maxSize: 15,
 *     minSize: 12,
 *     vpcZoneIdentifiers: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     mixedInstancesPolicy: {
 *         instancesDistribution: {
 *             onDemandBaseCapacity: 0,
 *             onDemandPercentageAboveBaseCapacity: 25,
 *             spotAllocationStrategy: "capacity-optimized",
 *         },
 *         launchTemplate: {
 *             launchTemplateSpecification: {
 *                 launchTemplateId: example.id,
 *             },
 *             overrides: [
 *                 {
 *                     instanceType: "c4.large",
 *                     weightedCapacity: "3",
 *                 },
 *                 {
 *                     instanceType: "c3.large",
 *                     weightedCapacity: "2",
 *                 },
 *             ],
 *         },
 *     },
 * });
 * ```
 *
 * ### Mixed Instances Policy with Instance level LaunchTemplateSpecification Overrides
 *
 * When using a diverse instance set, some instance types might require a launch template with configuration values unique to that instance type such as a different AMI (Graviton2), architecture specific user data script, different EBS configuration, or different networking configuration.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.LaunchTemplate("example", {
 *     namePrefix: "example",
 *     imageId: exampleAwsAmi.id,
 *     instanceType: "c5.large",
 * });
 * const example2 = new aws.ec2.LaunchTemplate("example2", {
 *     namePrefix: "example2",
 *     imageId: example2AwsAmi.id,
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 1,
 *     minSize: 1,
 *     mixedInstancesPolicy: {
 *         launchTemplate: {
 *             launchTemplateSpecification: {
 *                 launchTemplateId: example.id,
 *             },
 *             overrides: [
 *                 {
 *                     instanceType: "c4.large",
 *                     weightedCapacity: "3",
 *                 },
 *                 {
 *                     instanceType: "c6g.large",
 *                     launchTemplateSpecification: {
 *                         launchTemplateId: example2.id,
 *                     },
 *                     weightedCapacity: "2",
 *                 },
 *             ],
 *         },
 *     },
 * });
 * ```
 *
 * ### Mixed Instances Policy with Attribute-based Instance Type Selection
 *
 * As an alternative to manually choosing instance types when creating a mixed instances group, you can specify a set of instance attributes that describe your compute requirements.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.LaunchTemplate("example", {
 *     namePrefix: "example",
 *     imageId: exampleAwsAmi.id,
 *     instanceType: "c5.large",
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 1,
 *     minSize: 1,
 *     mixedInstancesPolicy: {
 *         launchTemplate: {
 *             launchTemplateSpecification: {
 *                 launchTemplateId: example.id,
 *             },
 *             overrides: [{
 *                 instanceRequirements: {
 *                     memoryMib: {
 *                         min: 1000,
 *                     },
 *                     vcpuCount: {
 *                         min: 4,
 *                     },
 *                 },
 *             }],
 *         },
 *     },
 * });
 * ```
 *
 * ### Dynamic tagging
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const config = new pulumi.Config();
 * const extraTags = config.getObject("extraTags") || [
 *     {
 *         key: "Foo",
 *         propagateAtLaunch: true,
 *         value: "Bar",
 *     },
 *     {
 *         key: "Baz",
 *         propagateAtLaunch: true,
 *         value: "Bam",
 *     },
 * ];
 * const test = new aws.autoscaling.Group("test", {
 *     tags: [
 *         {
 *             key: "explicit1",
 *             value: "value1",
 *             propagateAtLaunch: true,
 *         },
 *         {
 *             key: "explicit2",
 *             value: "value2",
 *             propagateAtLaunch: true,
 *         },
 *     ],
 *     name: "foobar3-test",
 *     maxSize: 5,
 *     minSize: 2,
 *     launchConfiguration: foobar.name,
 *     vpcZoneIdentifiers: [
 *         example1.id,
 *         example2.id,
 *     ],
 * });
 * ```
 *
 * ### Automatically refresh all instances after the group is updated
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = aws.ec2.getAmi({
 *     mostRecent: true,
 *     owners: ["amazon"],
 *     filters: [{
 *         name: "name",
 *         values: ["amzn-ami-hvm-*-x86_64-gp2"],
 *     }],
 * });
 * const exampleLaunchTemplate = new aws.ec2.LaunchTemplate("example", {
 *     imageId: example.then(example => example.id),
 *     instanceType: "t3.nano",
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 2,
 *     minSize: 1,
 *     launchTemplate: {
 *         id: exampleLaunchTemplate.id,
 *         version: exampleLaunchTemplate.latestVersion,
 *     },
 *     tags: [{
 *         key: "Key",
 *         value: "Value",
 *         propagateAtLaunch: true,
 *     }],
 *     instanceRefresh: {
 *         strategy: "Rolling",
 *         preferences: {
 *             minHealthyPercentage: 50,
 *         },
 *         triggers: ["tag"],
 *     },
 * });
 * ```
 *
 * ### Auto Scaling group with Warm Pool
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.LaunchTemplate("example", {
 *     namePrefix: "example",
 *     imageId: exampleAwsAmi.id,
 *     instanceType: "c5.large",
 * });
 * const exampleGroup = new aws.autoscaling.Group("example", {
 *     availabilityZones: ["us-east-1a"],
 *     desiredCapacity: 1,
 *     maxSize: 5,
 *     minSize: 1,
 *     warmPool: {
 *         poolState: "Hibernated",
 *         minSize: 1,
 *         maxGroupPreparedCapacity: 10,
 *         instanceReusePolicy: {
 *             reuseOnScaleIn: true,
 *         },
 *     },
 * });
 * ```
 *
 * ### Auto Scaling group with Traffic Sources
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const test = new aws.autoscaling.Group("test", {
 *     trafficSources: testAwsVpclatticeTargetGroup.map(__item => __item).map((v, k) => ({key: k, value: v})).map(entry => ({
 *         identifier: entry.value.arn,
 *         type: "vpc-lattice",
 *     })),
 *     vpcZoneIdentifiers: testAwsSubnet.id,
 *     maxSize: 1,
 *     minSize: 1,
 *     forceDelete: true,
 * });
 * ```
 *
 * ## Waiting for Capacity
 *
 * A newly-created ASG is initially empty and begins to scale to `minSize` (or
 * `desiredCapacity`, if specified) by launching instances using the provided
 * Launch Configuration. These instances take time to launch and boot.
 *
 * On ASG Update, changes to these values also take time to result in the target
 * number of instances providing service.
 *
 * This provider provides two mechanisms to help consistently manage ASG scale up
 * time across dependent resources.
 *
 * #### Waiting for ASG Capacity
 *
 * The first is default behavior. This provider waits after ASG creation for
 * `minSize` (or `desiredCapacity`, if specified) healthy instances to show up
 * in the ASG before continuing.
 *
 * If `minSize` or `desiredCapacity` are changed in a subsequent update,
 * this provider will also wait for the correct number of healthy instances before
 * continuing.
 *
 * This provider considers an instance "healthy" when the ASG reports `HealthStatus:
 * "Healthy"` and `LifecycleState: "InService"`. See the [AWS AutoScaling
 * Docs](https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html)
 * for more information on an ASG's lifecycle.
 *
 * This provider will wait for healthy instances for up to
 * `waitForCapacityTimeout`. If ASG creation is taking more than a few minutes,
 * it's worth investigating for scaling activity errors, which can be caused by
 * problems with the selected Launch Configuration.
 *
 * Setting `waitForCapacityTimeout` to `"0"` disables ASG Capacity waiting.
 *
 * #### Waiting for ELB Capacity
 *
 * The second mechanism is optional, and affects ASGs with attached ELBs specified
 * via the `loadBalancers` attribute or with ALBs specified with `targetGroupArns`.
 *
 * The `minElbCapacity` parameter causes the provider to wait for at least the
 * requested number of instances to show up `"InService"` in all attached ELBs
 * during ASG creation. It has no effect on ASG updates.
 *
 * If `waitForElbCapacity` is set, the provider will wait for exactly that number
 * of Instances to be `"InService"` in all attached ELBs on both creation and
 * updates.
 *
 * These parameters can be used to ensure that service is being provided before
 * the provider moves on. If new instances don't pass the ELB's health checks for any
 * reason, the apply will time out, and the ASG will be marked as
 * tainted (i.e., marked to be destroyed in a follow up run).
 *
 * As with ASG Capacity, the provider will wait for up to `waitForCapacityTimeout`
 * for the proper number of instances to be healthy.
 *
 * #### Troubleshooting Capacity Waiting Timeouts
 *
 * If ASG creation takes more than a few minutes, this could indicate one of a
 * number of configuration problems. See the [AWS Docs on Load Balancer
 * Troubleshooting](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-troubleshooting.html)
 * for more information.
 *
 * ## Import
 *
 * Using `pulumi import`, import Auto Scaling Groups using the `name`. For example:
 *
 * ```sh
 * $ pulumi import aws:autoscaling/group:Group web web-asg
 * ```
 */
class Group extends pulumi.CustomResource {
    /**
     * Get an existing Group resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new Group(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of Group.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Group.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["arn"] = state ? state.arn : undefined;
            resourceInputs["availabilityZoneDistribution"] = state ? state.availabilityZoneDistribution : undefined;
            resourceInputs["availabilityZones"] = state ? state.availabilityZones : undefined;
            resourceInputs["capacityRebalance"] = state ? state.capacityRebalance : undefined;
            resourceInputs["context"] = state ? state.context : undefined;
            resourceInputs["defaultCooldown"] = state ? state.defaultCooldown : undefined;
            resourceInputs["defaultInstanceWarmup"] = state ? state.defaultInstanceWarmup : undefined;
            resourceInputs["desiredCapacity"] = state ? state.desiredCapacity : undefined;
            resourceInputs["desiredCapacityType"] = state ? state.desiredCapacityType : undefined;
            resourceInputs["enabledMetrics"] = state ? state.enabledMetrics : undefined;
            resourceInputs["forceDelete"] = state ? state.forceDelete : undefined;
            resourceInputs["forceDeleteWarmPool"] = state ? state.forceDeleteWarmPool : undefined;
            resourceInputs["healthCheckGracePeriod"] = state ? state.healthCheckGracePeriod : undefined;
            resourceInputs["healthCheckType"] = state ? state.healthCheckType : undefined;
            resourceInputs["ignoreFailedScalingActivities"] = state ? state.ignoreFailedScalingActivities : undefined;
            resourceInputs["initialLifecycleHooks"] = state ? state.initialLifecycleHooks : undefined;
            resourceInputs["instanceMaintenancePolicy"] = state ? state.instanceMaintenancePolicy : undefined;
            resourceInputs["instanceRefresh"] = state ? state.instanceRefresh : undefined;
            resourceInputs["launchConfiguration"] = state ? state.launchConfiguration : undefined;
            resourceInputs["launchTemplate"] = state ? state.launchTemplate : undefined;
            resourceInputs["loadBalancers"] = state ? state.loadBalancers : undefined;
            resourceInputs["maxInstanceLifetime"] = state ? state.maxInstanceLifetime : undefined;
            resourceInputs["maxSize"] = state ? state.maxSize : undefined;
            resourceInputs["metricsGranularity"] = state ? state.metricsGranularity : undefined;
            resourceInputs["minElbCapacity"] = state ? state.minElbCapacity : undefined;
            resourceInputs["minSize"] = state ? state.minSize : undefined;
            resourceInputs["mixedInstancesPolicy"] = state ? state.mixedInstancesPolicy : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["namePrefix"] = state ? state.namePrefix : undefined;
            resourceInputs["placementGroup"] = state ? state.placementGroup : undefined;
            resourceInputs["predictedCapacity"] = state ? state.predictedCapacity : undefined;
            resourceInputs["protectFromScaleIn"] = state ? state.protectFromScaleIn : undefined;
            resourceInputs["serviceLinkedRoleArn"] = state ? state.serviceLinkedRoleArn : undefined;
            resourceInputs["suspendedProcesses"] = state ? state.suspendedProcesses : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["targetGroupArns"] = state ? state.targetGroupArns : undefined;
            resourceInputs["terminationPolicies"] = state ? state.terminationPolicies : undefined;
            resourceInputs["trafficSources"] = state ? state.trafficSources : undefined;
            resourceInputs["vpcZoneIdentifiers"] = state ? state.vpcZoneIdentifiers : undefined;
            resourceInputs["waitForCapacityTimeout"] = state ? state.waitForCapacityTimeout : undefined;
            resourceInputs["waitForElbCapacity"] = state ? state.waitForElbCapacity : undefined;
            resourceInputs["warmPool"] = state ? state.warmPool : undefined;
            resourceInputs["warmPoolSize"] = state ? state.warmPoolSize : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.maxSize === undefined) && !opts.urn) {
                throw new Error("Missing required property 'maxSize'");
            }
            if ((!args || args.minSize === undefined) && !opts.urn) {
                throw new Error("Missing required property 'minSize'");
            }
            resourceInputs["availabilityZoneDistribution"] = args ? args.availabilityZoneDistribution : undefined;
            resourceInputs["availabilityZones"] = args ? args.availabilityZones : undefined;
            resourceInputs["capacityRebalance"] = args ? args.capacityRebalance : undefined;
            resourceInputs["context"] = args ? args.context : undefined;
            resourceInputs["defaultCooldown"] = args ? args.defaultCooldown : undefined;
            resourceInputs["defaultInstanceWarmup"] = args ? args.defaultInstanceWarmup : undefined;
            resourceInputs["desiredCapacity"] = args ? args.desiredCapacity : undefined;
            resourceInputs["desiredCapacityType"] = args ? args.desiredCapacityType : undefined;
            resourceInputs["enabledMetrics"] = args ? args.enabledMetrics : undefined;
            resourceInputs["forceDelete"] = args ? args.forceDelete : undefined;
            resourceInputs["forceDeleteWarmPool"] = args ? args.forceDeleteWarmPool : undefined;
            resourceInputs["healthCheckGracePeriod"] = args ? args.healthCheckGracePeriod : undefined;
            resourceInputs["healthCheckType"] = args ? args.healthCheckType : undefined;
            resourceInputs["ignoreFailedScalingActivities"] = args ? args.ignoreFailedScalingActivities : undefined;
            resourceInputs["initialLifecycleHooks"] = args ? args.initialLifecycleHooks : undefined;
            resourceInputs["instanceMaintenancePolicy"] = args ? args.instanceMaintenancePolicy : undefined;
            resourceInputs["instanceRefresh"] = args ? args.instanceRefresh : undefined;
            resourceInputs["launchConfiguration"] = args ? args.launchConfiguration : undefined;
            resourceInputs["launchTemplate"] = args ? args.launchTemplate : undefined;
            resourceInputs["loadBalancers"] = args ? args.loadBalancers : undefined;
            resourceInputs["maxInstanceLifetime"] = args ? args.maxInstanceLifetime : undefined;
            resourceInputs["maxSize"] = args ? args.maxSize : undefined;
            resourceInputs["metricsGranularity"] = args ? args.metricsGranularity : undefined;
            resourceInputs["minElbCapacity"] = args ? args.minElbCapacity : undefined;
            resourceInputs["minSize"] = args ? args.minSize : undefined;
            resourceInputs["mixedInstancesPolicy"] = args ? args.mixedInstancesPolicy : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["namePrefix"] = args ? args.namePrefix : undefined;
            resourceInputs["placementGroup"] = args ? args.placementGroup : undefined;
            resourceInputs["protectFromScaleIn"] = args ? args.protectFromScaleIn : undefined;
            resourceInputs["serviceLinkedRoleArn"] = args ? args.serviceLinkedRoleArn : undefined;
            resourceInputs["suspendedProcesses"] = args ? args.suspendedProcesses : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["targetGroupArns"] = args ? args.targetGroupArns : undefined;
            resourceInputs["terminationPolicies"] = args ? args.terminationPolicies : undefined;
            resourceInputs["trafficSources"] = args ? args.trafficSources : undefined;
            resourceInputs["vpcZoneIdentifiers"] = args ? args.vpcZoneIdentifiers : undefined;
            resourceInputs["waitForCapacityTimeout"] = args ? args.waitForCapacityTimeout : undefined;
            resourceInputs["waitForElbCapacity"] = args ? args.waitForElbCapacity : undefined;
            resourceInputs["warmPool"] = args ? args.warmPool : undefined;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["predictedCapacity"] = undefined /*out*/;
            resourceInputs["warmPoolSize"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Group.__pulumiType, name, resourceInputs, opts);
    }
}
exports.Group = Group;
/** @internal */
Group.__pulumiType = 'aws:autoscaling/group:Group';
//# sourceMappingURL=group.js.map