"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.DbInstance = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Resource for managing an Amazon Timestream for InfluxDB database instance.
 *
 * ## Example Usage
 *
 * ### Basic Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.timestreaminfluxdb.DbInstance("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [exampleid],
 *     vpcSecurityGroupIds: [exampleAwsSecurityGroup.id],
 *     name: "example-db-instance",
 * });
 * ```
 *
 * ### Usage with Prerequisite Resources
 *
 * All Timestream for InfluxDB instances require a VPC, subnet, and security group. The following example shows how these prerequisite resources can be created and used with `aws.timestreaminfluxdb.DbInstance`.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.Vpc("example", {cidrBlock: "10.0.0.0/16"});
 * const exampleSubnet = new aws.ec2.Subnet("example", {
 *     vpcId: example.id,
 *     cidrBlock: "10.0.1.0/24",
 * });
 * const exampleSecurityGroup = new aws.ec2.SecurityGroup("example", {
 *     name: "example",
 *     vpcId: example.id,
 * });
 * const exampleDbInstance = new aws.timestreaminfluxdb.DbInstance("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [exampleSubnet.id],
 *     vpcSecurityGroupIds: [exampleSecurityGroup.id],
 *     name: "example-db-instance",
 * });
 * ```
 *
 * ### Usage with S3 Log Delivery Enabled
 *
 * You can use an S3 bucket to store logs generated by your Timestream for InfluxDB instance. The following example shows what resources and arguments are required to configure an S3 bucket for logging, including the IAM policy that needs to be set in order to allow Timestream for InfluxDB to place logs in your S3 bucket. The configuration of the required VPC, security group, and subnet have been left out of the example for brevity.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleBucketV2 = new aws.s3.BucketV2("example", {bucket: "example-s3-bucket"});
 * const example = aws.iam.getPolicyDocumentOutput({
 *     statements: [{
 *         actions: ["s3:PutObject"],
 *         principals: [{
 *             type: "Service",
 *             identifiers: ["timestream-influxdb.amazonaws.com"],
 *         }],
 *         resources: [pulumi.interpolate`${exampleBucketV2.arn}/*`],
 *     }],
 * });
 * const exampleBucketPolicy = new aws.s3.BucketPolicy("example", {
 *     bucket: exampleBucketV2.id,
 *     policy: example.apply(example => example.json),
 * });
 * const exampleDbInstance = new aws.timestreaminfluxdb.DbInstance("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [exampleAwsSubnet.id],
 *     vpcSecurityGroupIds: [exampleAwsSecurityGroup.id],
 *     name: "example-db-instance",
 *     logDeliveryConfiguration: {
 *         s3Configuration: {
 *             bucketName: exampleBucketV2.name,
 *             enabled: true,
 *         },
 *     },
 * });
 * ```
 *
 * ### Usage with MultiAZ Deployment
 *
 * To use multi-region availability, at least two subnets must be created in different availability zones and used with your Timestream for InfluxDB instance.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example1 = new aws.ec2.Subnet("example_1", {
 *     vpcId: exampleAwsVpc.id,
 *     cidrBlock: "10.0.1.0/24",
 *     availabilityZone: "us-west-2a",
 * });
 * const example2 = new aws.ec2.Subnet("example_2", {
 *     vpcId: exampleAwsVpc.id,
 *     cidrBlock: "10.0.2.0/24",
 *     availabilityZone: "us-west-2b",
 * });
 * const example = new aws.timestreaminfluxdb.DbInstance("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     deploymentType: "WITH_MULTIAZ_STANDBY",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     vpcSecurityGroupIds: [exampleAwsSecurityGroup.id],
 *     name: "example-db-instance",
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import Timestream for InfluxDB Db Instance using its identifier. For example:
 *
 * ```sh
 * $ pulumi import aws:timestreaminfluxdb/dbInstance:DbInstance example 12345abcde
 * ```
 */
class DbInstance extends pulumi.CustomResource {
    /**
     * Get an existing DbInstance resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new DbInstance(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of DbInstance.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DbInstance.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["allocatedStorage"] = state ? state.allocatedStorage : undefined;
            resourceInputs["arn"] = state ? state.arn : undefined;
            resourceInputs["availabilityZone"] = state ? state.availabilityZone : undefined;
            resourceInputs["bucket"] = state ? state.bucket : undefined;
            resourceInputs["dbInstanceType"] = state ? state.dbInstanceType : undefined;
            resourceInputs["dbParameterGroupIdentifier"] = state ? state.dbParameterGroupIdentifier : undefined;
            resourceInputs["dbStorageType"] = state ? state.dbStorageType : undefined;
            resourceInputs["deploymentType"] = state ? state.deploymentType : undefined;
            resourceInputs["endpoint"] = state ? state.endpoint : undefined;
            resourceInputs["influxAuthParametersSecretArn"] = state ? state.influxAuthParametersSecretArn : undefined;
            resourceInputs["logDeliveryConfiguration"] = state ? state.logDeliveryConfiguration : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["organization"] = state ? state.organization : undefined;
            resourceInputs["password"] = state ? state.password : undefined;
            resourceInputs["publiclyAccessible"] = state ? state.publiclyAccessible : undefined;
            resourceInputs["secondaryAvailabilityZone"] = state ? state.secondaryAvailabilityZone : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["tagsAll"] = state ? state.tagsAll : undefined;
            resourceInputs["timeouts"] = state ? state.timeouts : undefined;
            resourceInputs["username"] = state ? state.username : undefined;
            resourceInputs["vpcSecurityGroupIds"] = state ? state.vpcSecurityGroupIds : undefined;
            resourceInputs["vpcSubnetIds"] = state ? state.vpcSubnetIds : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.allocatedStorage === undefined) && !opts.urn) {
                throw new Error("Missing required property 'allocatedStorage'");
            }
            if ((!args || args.bucket === undefined) && !opts.urn) {
                throw new Error("Missing required property 'bucket'");
            }
            if ((!args || args.dbInstanceType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dbInstanceType'");
            }
            if ((!args || args.organization === undefined) && !opts.urn) {
                throw new Error("Missing required property 'organization'");
            }
            if ((!args || args.password === undefined) && !opts.urn) {
                throw new Error("Missing required property 'password'");
            }
            if ((!args || args.username === undefined) && !opts.urn) {
                throw new Error("Missing required property 'username'");
            }
            if ((!args || args.vpcSecurityGroupIds === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vpcSecurityGroupIds'");
            }
            if ((!args || args.vpcSubnetIds === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vpcSubnetIds'");
            }
            resourceInputs["allocatedStorage"] = args ? args.allocatedStorage : undefined;
            resourceInputs["bucket"] = args ? args.bucket : undefined;
            resourceInputs["dbInstanceType"] = args ? args.dbInstanceType : undefined;
            resourceInputs["dbParameterGroupIdentifier"] = args ? args.dbParameterGroupIdentifier : undefined;
            resourceInputs["dbStorageType"] = args ? args.dbStorageType : undefined;
            resourceInputs["deploymentType"] = args ? args.deploymentType : undefined;
            resourceInputs["logDeliveryConfiguration"] = args ? args.logDeliveryConfiguration : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["organization"] = args ? args.organization : undefined;
            resourceInputs["password"] = (args === null || args === void 0 ? void 0 : args.password) ? pulumi.secret(args.password) : undefined;
            resourceInputs["publiclyAccessible"] = args ? args.publiclyAccessible : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["timeouts"] = args ? args.timeouts : undefined;
            resourceInputs["username"] = args ? args.username : undefined;
            resourceInputs["vpcSecurityGroupIds"] = args ? args.vpcSecurityGroupIds : undefined;
            resourceInputs["vpcSubnetIds"] = args ? args.vpcSubnetIds : undefined;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["availabilityZone"] = undefined /*out*/;
            resourceInputs["endpoint"] = undefined /*out*/;
            resourceInputs["influxAuthParametersSecretArn"] = undefined /*out*/;
            resourceInputs["secondaryAvailabilityZone"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["password"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(DbInstance.__pulumiType, name, resourceInputs, opts);
    }
}
exports.DbInstance = DbInstance;
/** @internal */
DbInstance.__pulumiType = 'aws:timestreaminfluxdb/dbInstance:DbInstance';
//# sourceMappingURL=dbInstance.js.map