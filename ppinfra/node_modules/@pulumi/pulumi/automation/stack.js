"use strict";
// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const pathlib = __importStar(require("path"));
const readline = __importStar(require("readline"));
const upath = __importStar(require("upath"));
const grpc = __importStar(require("@grpc/grpc-js"));
const tail_file_1 = __importDefault(require("@logdna/tail-file"));
const log = __importStar(require("../log"));
const errors_1 = require("./errors");
const localWorkspace_1 = require("./localWorkspace");
const server_1 = require("./server");
const langrpc = __importStar(require("../proto/language_grpc_pb"));
/**
 * {@link Stack} is an isolated, independently configurable instance of a Pulumi
 * program. {@link Stack} exposes methods for the full Pulumi lifecycle
 * (up/preview/refresh/destroy), as well as managing configuration. Multiple
 * {@link Stacks} are commonly used to denote different phases of development
 * (such as development, staging and production) or feature branches (such as
 * feature-x-dev, jane-feature-x-dev).
 *
 * @alpha
 */
class Stack {
    constructor(name, workspace, mode) {
        this.name = name;
        this.workspace = workspace;
        switch (mode) {
            case "create":
                this.ready = workspace.createStack(name);
                return this;
            case "select":
                this.ready = workspace.selectStack(name);
                return this;
            case "createOrSelect":
                this.ready = workspace.selectStack(name).catch((err) => {
                    if (err instanceof errors_1.StackNotFoundError) {
                        return workspace.createStack(name);
                    }
                    throw err;
                });
                return this;
            default:
                throw new Error(`unexpected Stack creation mode: ${mode}`);
        }
    }
    /**
     * Creates a new stack using the given workspace, and stack name.
     * It fails if a stack with that name already exists
     *
     * @param name
     *  The name identifying the Stack.
     * @param workspace
     *  The Workspace the Stack was created from.
     */
    static create(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "create");
            yield stack.ready;
            return stack;
        });
    }
    /**
     * Selects stack using the given workspace and stack name. It returns an
     * error if the given stack does not exist.
     *
     * @param name
     *  The name identifying the Stack.
     * @param workspace
     *  The {@link Workspace} the stack will be created from.
     */
    static select(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "select");
            yield stack.ready;
            return stack;
        });
    }
    /**
     * Creates a new stack using the given workspace and stack name if the stack
     * does not already exist, or falls back to selecting the existing stack. If
     * the stack does not exist, it will be created and selected.
     *
     * @param name
     *  The name identifying the Stack.
     * @param workspace
     *  The {@link Workspace} the stack will be created from.
     */
    static createOrSelect(name, workspace) {
        return __awaiter(this, void 0, void 0, function* () {
            const stack = new Stack(name, workspace, "createOrSelect");
            yield stack.ready;
            return stack;
        });
    }
    readLines(logPath, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventLogTail = new tail_file_1.default(logPath, { startPos: 0, pollFileIntervalMs: 200 }).on("tail_error", (err) => {
                throw err;
            });
            yield eventLogTail.start();
            const lineSplitter = readline.createInterface({ input: eventLogTail });
            lineSplitter.on("line", (line) => {
                let event;
                try {
                    event = JSON.parse(line);
                    callback(event);
                }
                catch (e) {
                    log.warn(`Failed to parse engine event
If you're seeing this warning, please comment on https://github.com/pulumi/pulumi/issues/6768 with the event and any
details about your environment.
Event: ${line}\n${e.toString()}`);
                }
            });
            return {
                tail: eventLogTail,
                rl: lineSplitter,
            };
        });
    }
    /**
     * Creates or updates the resources in a stack by executing the program in
     * the {@link Workspace.}
     *
     * @param opts
     *  Options to customize the behavior of the update.
     *
     * @see https://www.pulumi.com/docs/cli/commands/pulumi_up/
     */
    up(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["up", "--yes", "--skip-preview"];
            let kind = execKind.local;
            let program = this.workspace.program;
            args.push(...this.remoteArgs());
            if (opts) {
                if (opts.program) {
                    program = opts.program;
                }
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.refresh) {
                    args.push("--refresh");
                }
                if (opts.diff) {
                    args.push("--diff");
                }
                if (opts.replace) {
                    for (const rURN of opts.replace) {
                        args.push("--replace", rURN);
                    }
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.policyPacks) {
                    for (const pack of opts.policyPacks) {
                        args.push("--policy-pack", pack);
                    }
                }
                if (opts.policyPackConfigs) {
                    for (const packConfig of opts.policyPackConfigs) {
                        args.push("--policy-pack-config", packConfig);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
                if (opts.userAgent) {
                    args.push("--exec-agent", opts.userAgent);
                }
                if (opts.plan) {
                    args.push("--plan", opts.plan);
                }
                if (opts.continueOnError) {
                    args.push("--continue-on-error");
                }
                if (opts.attachDebugger) {
                    args.push("--attach-debugger");
                }
                applyGlobalOpts(opts, args);
            }
            let onExit = (hasError) => {
                return;
            };
            let didError = false;
            if (program) {
                kind = execKind.inline;
                const server = new grpc.Server({
                    "grpc.max_receive_message_length": server_1.maxRPCMessageSize,
                });
                const languageServer = new server_1.LanguageServer(program);
                server.addService(langrpc.LanguageRuntimeService, languageServer);
                const port = yield new Promise((resolve, reject) => {
                    server.bindAsync(`127.0.0.1:0`, grpc.ServerCredentials.createInsecure(), (err, p) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(p);
                        }
                    });
                });
                onExit = (hasError) => {
                    languageServer.onPulumiExit(hasError);
                    server.forceShutdown();
                };
                args.push(`--client=127.0.0.1:${port}`);
            }
            args.push("--exec-kind", kind);
            let logPromise;
            let logFile;
            // Set up event log tailing
            if (opts === null || opts === void 0 ? void 0 : opts.onEvent) {
                const onEvent = opts.onEvent;
                logFile = createLogFile("up");
                args.push("--event-log", logFile);
                logPromise = this.readLines(logFile, (event) => {
                    onEvent(event);
                });
            }
            let upResult;
            try {
                upResult = yield this.runPulumiCmd(args, opts === null || opts === void 0 ? void 0 : opts.onOutput, opts === null || opts === void 0 ? void 0 : opts.signal);
            }
            catch (e) {
                didError = true;
                throw e;
            }
            finally {
                onExit(didError);
                yield cleanUp(logFile, yield logPromise);
            }
            // TODO: do this in parallel after this is fixed https://github.com/pulumi/pulumi/issues/6050
            const outputs = yield this.outputs();
            // If it's a remote workspace, explicitly set showSecrets to false to prevent attempting to
            // load the project file.
            const summary = yield this.info(!this.isRemote && (opts === null || opts === void 0 ? void 0 : opts.showSecrets));
            return {
                stdout: upResult.stdout,
                stderr: upResult.stderr,
                summary: summary,
                outputs: outputs,
            };
        });
    }
    /**
     * Performs a dry-run update to a stack, returning pending changes.
     *
     * @param opts Options to customize the behavior of the preview.
     *
     * @see https://www.pulumi.com/docs/cli/commands/pulumi_preview/
     */
    preview(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["preview"];
            let kind = execKind.local;
            let program = this.workspace.program;
            args.push(...this.remoteArgs());
            if (opts) {
                if (opts.program) {
                    program = opts.program;
                }
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.refresh) {
                    args.push("--refresh");
                }
                if (opts.diff) {
                    args.push("--diff");
                }
                if (opts.replace) {
                    for (const rURN of opts.replace) {
                        args.push("--replace", rURN);
                    }
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.policyPacks) {
                    for (const pack of opts.policyPacks) {
                        args.push("--policy-pack", pack);
                    }
                }
                if (opts.policyPackConfigs) {
                    for (const packConfig of opts.policyPackConfigs) {
                        args.push("--policy-pack-config", packConfig);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
                if (opts.userAgent) {
                    args.push("--exec-agent", opts.userAgent);
                }
                if (opts.plan) {
                    args.push("--save-plan", opts.plan);
                }
                if (opts.importFile) {
                    args.push("--import-file", opts.importFile);
                }
                if (opts.attachDebugger) {
                    args.push("--attach-debugger");
                }
                applyGlobalOpts(opts, args);
            }
            let onExit = (hasError) => {
                return;
            };
            let didError = false;
            if (program) {
                kind = execKind.inline;
                const server = new grpc.Server({
                    "grpc.max_receive_message_length": server_1.maxRPCMessageSize,
                });
                const languageServer = new server_1.LanguageServer(program);
                server.addService(langrpc.LanguageRuntimeService, languageServer);
                const port = yield new Promise((resolve, reject) => {
                    server.bindAsync(`127.0.0.1:0`, grpc.ServerCredentials.createInsecure(), (err, p) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(p);
                        }
                    });
                });
                onExit = (hasError) => {
                    languageServer.onPulumiExit(hasError);
                    server.forceShutdown();
                };
                args.push(`--client=127.0.0.1:${port}`);
            }
            args.push("--exec-kind", kind);
            // Set up event log tailing
            const logFile = createLogFile("preview");
            args.push("--event-log", logFile);
            let summaryEvent;
            const logPromise = this.readLines(logFile, (event) => {
                if (event.summaryEvent) {
                    summaryEvent = event.summaryEvent;
                }
                if (opts === null || opts === void 0 ? void 0 : opts.onEvent) {
                    const onEvent = opts.onEvent;
                    onEvent(event);
                }
            });
            let previewResult;
            try {
                previewResult = yield this.runPulumiCmd(args, opts === null || opts === void 0 ? void 0 : opts.onOutput, opts === null || opts === void 0 ? void 0 : opts.signal);
            }
            catch (e) {
                didError = true;
                throw e;
            }
            finally {
                onExit(didError);
                yield cleanUp(logFile, yield logPromise);
            }
            if (!summaryEvent) {
                log.warn("Failed to parse summary event, but preview succeeded. PreviewResult `changeSummary` will be empty.");
            }
            return {
                stdout: previewResult.stdout,
                stderr: previewResult.stderr,
                changeSummary: (summaryEvent === null || summaryEvent === void 0 ? void 0 : summaryEvent.resourceChanges) || {},
            };
        });
    }
    /**
     * Compares the current stack’s resource state with the state known to exist
     * in the actual cloud provider. Any such changes are adopted into the
     * current stack.
     *
     * @param opts
     *  Options to customize the behavior of the refresh.
     */
    refresh(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["refresh", "--yes"];
            args.push((opts === null || opts === void 0 ? void 0 : opts.previewOnly) ? "--preview-only" : "--skip-preview");
            args.push(...this.remoteArgs());
            if (opts) {
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.expectNoChanges) {
                    args.push("--expect-no-changes");
                }
                if (opts.clearPendingCreates) {
                    args.push("--clear-pending-creates");
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
                if (opts.userAgent) {
                    args.push("--exec-agent", opts.userAgent);
                }
                applyGlobalOpts(opts, args);
            }
            let logPromise;
            let logFile;
            // Set up event log tailing
            if (opts === null || opts === void 0 ? void 0 : opts.onEvent) {
                const onEvent = opts.onEvent;
                logFile = createLogFile("refresh");
                args.push("--event-log", logFile);
                logPromise = this.readLines(logFile, (event) => {
                    onEvent(event);
                });
            }
            const kind = this.workspace.program ? execKind.inline : execKind.local;
            args.push("--exec-kind", kind);
            let refResult;
            try {
                refResult = yield this.runPulumiCmd(args, opts === null || opts === void 0 ? void 0 : opts.onOutput, opts === null || opts === void 0 ? void 0 : opts.signal);
            }
            finally {
                yield cleanUp(logFile, yield logPromise);
            }
            // If it's a remote workspace, explicitly set showSecrets to false to prevent attempting to
            // load the project file.
            const summary = yield this.info(!this.isRemote && (opts === null || opts === void 0 ? void 0 : opts.showSecrets));
            return {
                stdout: refResult.stdout,
                stderr: refResult.stderr,
                summary: summary,
            };
        });
    }
    /**
     * Deletes all resources in a stack. By default, this method will leave all
     * history and configuration intact. If `opts.remove` is set, the entire
     * stack and its configuration will also be deleted.
     *
     * @param opts
     *  Options to customize the behavior of the destroy.
     */
    destroy(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["destroy", "--yes", "--skip-preview"];
            args.push(...this.remoteArgs());
            if (opts) {
                if (opts.message) {
                    args.push("--message", opts.message);
                }
                if (opts.target) {
                    for (const tURN of opts.target) {
                        args.push("--target", tURN);
                    }
                }
                if (opts.targetDependents) {
                    args.push("--target-dependents");
                }
                if (opts.excludeProtected) {
                    args.push("--exclude-protected");
                }
                if (opts.continueOnError) {
                    args.push("--continue-on-error");
                }
                if (opts.parallel) {
                    args.push("--parallel", opts.parallel.toString());
                }
                if (opts.userAgent) {
                    args.push("--exec-agent", opts.userAgent);
                }
                if (opts.refresh) {
                    args.push("--refresh");
                }
                applyGlobalOpts(opts, args);
            }
            let logPromise;
            let logFile;
            // Set up event log tailing
            if (opts === null || opts === void 0 ? void 0 : opts.onEvent) {
                const onEvent = opts.onEvent;
                logFile = createLogFile("destroy");
                args.push("--event-log", logFile);
                logPromise = this.readLines(logFile, (event) => {
                    onEvent(event);
                });
            }
            const kind = this.workspace.program ? execKind.inline : execKind.local;
            args.push("--exec-kind", kind);
            let desResult;
            try {
                desResult = yield this.runPulumiCmd(args, opts === null || opts === void 0 ? void 0 : opts.onOutput, opts === null || opts === void 0 ? void 0 : opts.signal);
            }
            finally {
                yield cleanUp(logFile, yield logPromise);
            }
            // If it's a remote workspace, explicitly set showSecrets to false to prevent attempting to
            // load the project file.
            const summary = yield this.info(!this.isRemote && (opts === null || opts === void 0 ? void 0 : opts.showSecrets));
            // If `opts.remove` was set, remove the stack now. We take this approach
            // rather than passing `--remove` to `pulumi destroy` because the latter
            // would make it impossible for us to retrieve a summary of the
            // operation above for returning to the caller.
            if (opts === null || opts === void 0 ? void 0 : opts.remove) {
                yield this.workspace.removeStack(this.name);
            }
            return {
                stdout: desResult.stdout,
                stderr: desResult.stderr,
                summary: summary,
            };
        });
    }
    /**
     * Rename an existing stack
     */
    rename(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["stack", "rename", options.stackName];
            args.push(...this.remoteArgs());
            applyGlobalOpts(options, args);
            const renameResult = yield this.runPulumiCmd(args, options === null || options === void 0 ? void 0 : options.onOutput, options === null || options === void 0 ? void 0 : options.signal);
            if (this.isRemote && (options === null || options === void 0 ? void 0 : options.showSecrets)) {
                throw new Error("can't enable `showSecrets` for remote workspaces");
            }
            const summary = yield this.info(!this.isRemote && (options === null || options === void 0 ? void 0 : options.showSecrets));
            return {
                stdout: renameResult.stdout,
                stderr: renameResult.stderr,
                summary: summary,
            };
        });
    }
    /**
     * Import resources into the stack
     *
     * @param options Options to specify resources and customize the behavior of the import.
     */
    import(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["import", "--yes", "--skip-preview"];
            if (options.message) {
                args.push("--message", options.message);
            }
            applyGlobalOpts(options, args);
            let importResult;
            // for import operations, generate a temporary directory to store the following:
            //   - the import file when the user specifies resources to import
            //   - the output file for the generated code
            // we use the import file as input to the import command
            // we the output file to read the generated code and return it to the user
            let tempDir = "";
            try {
                tempDir = yield fs.promises.mkdtemp(pathlib.join(os.tmpdir(), "pulumi-import-"));
                const tempGeneratedCodeFile = pathlib.join(tempDir, "generated-code.txt");
                if (options.resources) {
                    // user has specified resources to import, write them to a temp import file
                    const tempImportFile = pathlib.join(tempDir, "import.json");
                    yield fs.promises.writeFile(tempImportFile, JSON.stringify({
                        nameTable: options.nameTable,
                        resources: options.resources,
                    }));
                    args.push("--file", tempImportFile);
                }
                if (options.generateCode === false) {
                    // --generate-code is set to true by default
                    // only use --generate-code=false if the user explicitly sets it to false
                    args.push("--generate-code=false");
                }
                else {
                    args.push("--out", tempGeneratedCodeFile);
                }
                if (options.protect === false) {
                    // --protect is set to true by default
                    // only use --protect=false if the user explicitly sets it to false
                    args.push(`--protect=false`);
                }
                if (options.converter) {
                    // if the user specifies a converter, pass it to `--from <converter>` argument of import
                    args.push("--from", options.converter);
                    if (options.converterArgs) {
                        // pass any additional arguments to the converter
                        // for example using {
                        //   converter: "terraform"
                        //   converterArgs: "./tfstate.json"
                        // }
                        // would be equivalent to `pulumi import --from terraform ./tfstate.json`
                        args.push("--");
                        args.push(...options.converterArgs);
                    }
                }
                importResult = yield this.runPulumiCmd(args, options.onOutput);
                const summary = yield this.info(!this.isRemote && options.showSecrets);
                let generatedCode = "";
                if (options.generateCode !== false) {
                    generatedCode = yield fs.promises.readFile(tempGeneratedCodeFile, "utf8");
                }
                return {
                    stdout: importResult.stdout,
                    stderr: importResult.stderr,
                    generatedCode: generatedCode,
                    summary: summary,
                };
            }
            finally {
                if (tempDir !== "") {
                    // clean up temp directory we used for the import file
                    yield fs.promises.rm(tempDir, { recursive: true });
                }
            }
        });
    }
    /**
     * Adds environments to the end of a stack's import list. Imported
     * environments are merged in order per the ESC merge rules. The list of
     * environments behaves as if it were the import list in an anonymous
     * environment.
     *
     * @param environments
     *  The names of the environments to add to the stack's configuration
     */
    addEnvironments(...environments) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workspace.addEnvironments(this.name, ...environments);
        });
    }
    /**
     * Returns the list of environments currently in the stack's import list.
     */
    listEnvironments() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.listEnvironments(this.name);
        });
    }
    /**
     * Removes an environment from a stack's import list.
     *
     * @param environment
     *  The name of the environment to remove from the stack's configuration
     */
    removeEnvironment(environment) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workspace.removeEnvironment(this.name, environment);
        });
    }
    /**
     * Returns the config value associated with the specified key.
     *
     * @param key
     *  The key to use for the config lookup
     * @param path
     *  The key contains a path to a property in a map or list to get
     */
    getConfig(key, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.getConfig(this.name, key, path);
        });
    }
    /**
     * Returns the full config map associated with the stack in the workspace.
     */
    getAllConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.getAllConfig(this.name);
        });
    }
    /**
     * Sets a config key-value pair on the stack in the associated Workspace.
     *
     * @param key
     *  The key to set.
     * @param value
     *  The config value to set.
     * @param path
     *  The key contains a path to a property in a map or list to set.
     */
    setConfig(key, value, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.setConfig(this.name, key, value, path);
        });
    }
    /**
     * Sets all specified config values on the stack in the associated
     * workspace.
     *
     * @param config
     *  The map of config key-value pairs to set.
     * @param path
     *  The keys contain a path to a property in a map or list to set.
     */
    setAllConfig(config, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.setAllConfig(this.name, config, path);
        });
    }
    /**
     * Removes the specified config key from the stack in the associated workspace.
     *
     * @param key
     *  The config key to remove.
     * @param path
     *  The key contains a path to a property in a map or list to remove.
     */
    removeConfig(key, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.removeConfig(this.name, key, path);
        });
    }
    /**
     * Removes the specified config keys from the stack in the associated workspace.
     *
     * @param keys
     *  The config keys to remove.
     * @param path
     *  The keys contain a path to a property in a map or list to remove.
     */
    removeAllConfig(keys, path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.removeAllConfig(this.name, keys, path);
        });
    }
    /**
     * Gets and sets the config map used with the last update.
     */
    refreshConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.refreshConfig(this.name);
        });
    }
    /**
     * Returns the tag value associated with specified key.
     *
     * @param key The key to use for the tag lookup.
     */
    getTag(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.getTag(this.name, key);
        });
    }
    /**
     * Sets a tag key-value pair on the stack in the associated workspace.
     *
     * @param key
     *  The tag key to set.
     * @param value
     *  The tag value to set.
     */
    setTag(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workspace.setTag(this.name, key, value);
        });
    }
    /**
     * Removes the specified tag key-value pair from the stack in the associated
     * workspace.
     *
     * @param key The tag key to remove.
     */
    removeTag(key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.workspace.removeTag(this.name, key);
        });
    }
    /**
     * Returns the full tag map associated with the stack in the workspace.
     */
    listTags() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.listTags(this.name);
        });
    }
    /**
     * Gets the current set of stack outputs from the last {@link Stack.up}.
     */
    outputs() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.stackOutputs(this.name);
        });
    }
    /**
     * Returns a list summarizing all previous and current results from Stack
     * lifecycle operations (up/preview/refresh/destroy).
     */
    history(pageSize, page, showSecrets) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["stack", "history", "--json"];
            if (showSecrets !== null && showSecrets !== void 0 ? showSecrets : true) {
                args.push("--show-secrets");
            }
            if (pageSize) {
                if (!page || page < 1) {
                    page = 1;
                }
                args.push("--page-size", Math.floor(pageSize).toString(), "--page", Math.floor(page).toString());
            }
            const result = yield this.runPulumiCmd(args);
            return JSON.parse(result.stdout, (key, value) => {
                if (key === "startTime" || key === "endTime") {
                    return new Date(value);
                }
                return value;
            });
        });
    }
    info(showSecrets) {
        return __awaiter(this, void 0, void 0, function* () {
            const history = yield this.history(1 /*pageSize*/, undefined, showSecrets);
            if (!history || history.length === 0) {
                return undefined;
            }
            return history[0];
        });
    }
    /**
     * Stops a stack's currently running update. It returns an error if no
     * update is currently running. Note that this operation is _very
     * dangerous_, and may leave the stack in an inconsistent state if a
     * resource operation was pending when the update was canceled.
     */
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runPulumiCmd(["cancel", "--yes"]);
        });
    }
    /**
     * Exports the deployment state of the stack. This can be combined with
     * {@link Stack.importStack} to edit a stack's state (such as recovery from
     * failed deployments).
     */
    exportStack() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.exportStack(this.name);
        });
    }
    /**
     * Imports the specified deployment state into a pre-existing stack. This
     * can be combined with {@link Stack.exportStack} to edit a stack's state
     * (such as recovery from failed deployments).
     *
     * @param state
     *  The stack state to import.
     */
    importStack(state) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.workspace.importStack(this.name, state);
        });
    }
    runPulumiCmd(args, onOutput, signal) {
        return __awaiter(this, void 0, void 0, function* () {
            let envs = {
                PULUMI_DEBUG_COMMANDS: "true",
            };
            if (this.isRemote) {
                envs["PULUMI_EXPERIMENTAL"] = "true";
            }
            const pulumiHome = this.workspace.pulumiHome;
            if (pulumiHome) {
                envs["PULUMI_HOME"] = pulumiHome;
            }
            envs = Object.assign(Object.assign({}, envs), this.workspace.envVars);
            const additionalArgs = yield this.workspace.serializeArgsForOp(this.name);
            args = [...args, "--stack", this.name, ...additionalArgs];
            const result = yield this.workspace.pulumiCommand.run(args, this.workspace.workDir, envs, onOutput, signal);
            yield this.workspace.postCommandCallback(this.name);
            return result;
        });
    }
    get isRemote() {
        const ws = this.workspace;
        return ws instanceof localWorkspace_1.LocalWorkspace ? ws.isRemote : false;
    }
    remoteArgs() {
        const ws = this.workspace;
        return ws instanceof localWorkspace_1.LocalWorkspace ? ws.remoteArgs() : [];
    }
}
exports.Stack = Stack;
function applyGlobalOpts(opts, args) {
    if (opts.color) {
        args.push("--color", opts.color);
    }
    if (opts.logFlow) {
        args.push("--logflow");
    }
    if (opts.logVerbosity) {
        args.push("--verbose", opts.logVerbosity.toString());
    }
    if (opts.logToStdErr) {
        args.push("--logtostderr");
    }
    if (opts.tracing) {
        args.push("--tracing", opts.tracing);
    }
    if (opts.debug) {
        args.push("--debug");
    }
    if (opts.suppressOutputs) {
        args.push("--suppress-outputs");
    }
    if (opts.suppressProgress) {
        args.push("--suppress-progress");
    }
}
/**
 * Returns a stack name formatted with the greatest possible specificity:
 * `org/project/stack` or `user/project/stack` Using this format avoids
 * ambiguity in stack identity guards creating or selecting the wrong stack.
 *
 * Note: legacy DIY backends (local file, S3, Azure Blob) do not support
 * stack names in this format, and instead only use the stack name without an
 * org/user or project to qualify it.
 *
 * See: https://github.com/pulumi/pulumi/issues/2522
 *
 * Non-legacy DIY backends do support the `org/project/stack` format, but `org`
 * must be set to "organization".
 *
 * @param org
 *  The org (or user) that contains the Stack.
 * @param project
 *  The project that parents the Stack.
 * @param stack
 *  The name of the Stack.
 */
function fullyQualifiedStackName(org, project, stack) {
    return `${org}/${project}/${stack}`;
}
exports.fullyQualifiedStackName = fullyQualifiedStackName;
const execKind = {
    local: "auto.local",
    inline: "auto.inline",
};
const createLogFile = (command) => {
    const logDir = fs.mkdtempSync(upath.joinSafe(os.tmpdir(), `automation-logs-${command}-`));
    const logFile = upath.joinSafe(logDir, "eventlog.txt");
    // just open/close the file to make sure it exists when we start polling.
    fs.closeSync(fs.openSync(logFile, "w"));
    return logFile;
};
const cleanUp = (logFile, rl) => __awaiter(void 0, void 0, void 0, function* () {
    if (rl) {
        // stop tailing
        yield rl.tail.quit();
        // close the readline interface
        rl.rl.close();
    }
    if (logFile) {
        // remove the logfile
        if (fs.rm) {
            // remove with Node JS 15.X+
            fs.rm(pathlib.dirname(logFile), { recursive: true }, () => {
                return;
            });
        }
        else {
            // remove with Node JS 14.X
            fs.rmdir(pathlib.dirname(logFile), { recursive: true }, () => {
                return;
            });
        }
    }
});
//# sourceMappingURL=stack.js.map