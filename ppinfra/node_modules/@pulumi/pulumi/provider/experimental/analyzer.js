"use strict";
// Copyright 2025-2025, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
// Use the TypeScript shim which allows us to fallback to a vendored version of
// TypeScript if the user has not installed it.
// TODO: we should consider requiring the user to install TypeScript and not
// rely on the shim. In any case, we should add tests for providers with
// different versions of TypeScript in their dependencies, to ensure the
// analyzer code is compatible with all of them.
const ts = require("../../typescript-shim");
var InputOutput;
(function (InputOutput) {
    InputOutput[InputOutput["Neither"] = 0] = "Neither";
    InputOutput[InputOutput["Input"] = 1] = "Input";
    InputOutput[InputOutput["Output"] = 2] = "Output";
})(InputOutput = exports.InputOutput || (exports.InputOutput = {}));
class Analyzer {
    constructor(dir, providerName) {
        this.components = {};
        this.typeDefinitions = {};
        this.docStrings = {};
        const configPath = `${dir}/tsconfig.json`;
        const config = ts.readConfigFile(configPath, ts.sys.readFile);
        const parsedConfig = ts.parseJsonConfigFileContent(config.config, ts.sys, path.dirname(configPath));
        this.providerName = providerName;
        parsedConfig.options["strictNullChecks"] = true;
        this.program = ts.createProgram({
            rootNames: parsedConfig.fileNames,
            options: parsedConfig.options,
        });
        this.checker = this.program.getTypeChecker();
    }
    analyze() {
        const sourceFiles = this.program.getSourceFiles();
        for (const sourceFile of sourceFiles) {
            if (sourceFile.fileName.includes("node_modules") || sourceFile.fileName.endsWith(".d.ts")) {
                continue;
            }
            this.analyzeFile(sourceFile);
        }
        return {
            components: this.components,
            typeDefinitions: this.typeDefinitions,
        };
    }
    findComponent(name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const sourceFiles = this.program.getSourceFiles();
            for (const sourceFile of sourceFiles) {
                if (sourceFile.fileName.includes("node_modules") || sourceFile.fileName.endsWith(".d.ts")) {
                    continue;
                }
                for (const node of sourceFile.statements) {
                    if (ts.isClassDeclaration(node) && this.isPulumiComponent(node) && node.name) {
                        if (ts.isClassDeclaration(node) && this.isPulumiComponent(node) && ((_a = node.name) === null || _a === void 0 ? void 0 : _a.text) === name) {
                            try {
                                const module = yield Promise.resolve().then(() => __importStar(require(sourceFile.fileName)));
                                return module[name];
                            }
                            catch (e) {
                                throw new Error(`Failed to import component '${name}': ${e}`);
                            }
                        }
                    }
                }
            }
            throw new Error(`Component '${name}' not found`);
        });
    }
    analyzeFile(sourceFile) {
        // We intentionally visit only the top-level nodes, because we only
        // support components defined at the top-level. We have no way to
        // instantiate components defined inside functions or methods.
        sourceFile.forEachChild((node) => {
            var _a;
            if (ts.isClassDeclaration(node) && this.isPulumiComponent(node) && node.name) {
                const component = this.analyzeComponent(node);
                this.components[component.name] = component;
            }
            else if ((ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node)) && node.name) {
                const dNode = node;
                let typeDocString = undefined;
                if ((dNode === null || dNode === void 0 ? void 0 : dNode.jsDoc) && dNode.jsDoc.length > 0) {
                    typeDocString = dNode.jsDoc.map((doc) => doc.comment).join("\n");
                }
                if (typeDocString) {
                    this.docStrings[(_a = node.name) === null || _a === void 0 ? void 0 : _a.text] = typeDocString;
                }
            }
        });
    }
    analyzeComponent(node) {
        var _a;
        const componentName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.text;
        // We expect exactly 1 constructor, and it must have and 'args'
        // parameter that has an interface type.
        const constructors = node.members.filter((member) => ts.isConstructorDeclaration(member));
        if (constructors.length !== 1) {
            throw new Error(`Component '${componentName}' must have exactly one constructor`);
        }
        const argsParam = constructors === null || constructors === void 0 ? void 0 : constructors[0].parameters.find((param) => {
            return ts.isIdentifier(param.name) && param.name.escapedText === "args";
        });
        if (!argsParam) {
            throw new Error(`Component '${componentName}' constructor must have an 'args' parameter`);
        }
        if (!argsParam.type) {
            throw new Error(`Component '${componentName}' constructor 'args' parameter must have a type`);
        }
        const args = this.checker.getTypeAtLocation(argsParam.type);
        const argsSymbol = args.getSymbol();
        if (!argsSymbol || !isInterface(argsSymbol)) {
            throw new Error(`Component '${componentName}' constructor 'args' parameter must be an interface`);
        }
        let inputs = {};
        if (argsSymbol.members) {
            inputs = this.analyzeSymbols({ component: componentName, inputOutput: InputOutput.Input, typeName: argsSymbol.getName() }, symbolTableToSymbols(argsSymbol.members), argsParam);
        }
        let outputs = {};
        const classType = this.checker.getTypeAtLocation(node);
        const classSymbol = classType.getSymbol();
        if (classSymbol === null || classSymbol === void 0 ? void 0 : classSymbol.members) {
            outputs = this.analyzeSymbols({ component: componentName, inputOutput: InputOutput.Output }, symbolTableToSymbols(classSymbol.members), node);
        }
        const definition = {
            name: componentName,
            inputs: inputs,
            outputs: outputs,
        };
        const dNode = node;
        if (dNode.jsDoc && dNode.jsDoc.length > 0) {
            definition.description = dNode.jsDoc.map((doc) => doc.comment).join("\n");
        }
        return definition;
    }
    isPulumiComponent(node) {
        if (!node.heritageClauses) {
            return false;
        }
        return node.heritageClauses.some((clause) => {
            return clause.types.some((clauseNode) => {
                var _a;
                const type = this.checker.getTypeAtLocation(clauseNode);
                const symbol = type.getSymbol();
                const matchesName = (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "ComponentResource";
                const sourceFile = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0].getSourceFile();
                const matchesSourceFile = (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("resource.ts")) || (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("resource.d.ts"));
                return matchesName && matchesSourceFile;
            });
        });
    }
    analyzeSymbols(context, symbols, location) {
        const properties = {};
        symbols.forEach((member) => {
            if (!isPropertyDeclaration(member)) {
                return;
            }
            const name = member.escapedName;
            properties[name] = this.analyzeSymbol(Object.assign(Object.assign({}, context), { property: name }), member, location);
        });
        return properties;
    }
    analyzeSymbol(context, symbol, location) {
        // Check if the property is optional, e.g.: myProp?: string; This is
        // defined on the symbol, not the type.
        const propType = this.checker.getTypeOfSymbolAtLocation(symbol, location);
        const optional = isOptional(symbol);
        const dNode = symbol.valueDeclaration;
        let docString = undefined;
        if ((dNode === null || dNode === void 0 ? void 0 : dNode.jsDoc) && dNode.jsDoc.length > 0) {
            docString = dNode.jsDoc.map((doc) => doc.comment).join("\n");
        }
        return this.analyzeType(Object.assign(Object.assign({}, context), { inputOutput: InputOutput.Neither }), propType, location, optional, docString);
    }
    analyzeType(context, type, location, optional = false, docString = undefined) {
        var _a, _b, _c;
        if (isSimpleType(type)) {
            const prop = { type: tsTypeToPropertyType(type) };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isInput(type)) {
            // Grab the promise type from the `T | Promise<T> | OutputInstance<T>`
            // union, and get the type reference `T` from there. With that we
            // can recursively analyze the type, passing through the optional
            // flag. The type can now not be plain anymore, since it's in an
            // input.
            const base = (_b = (_a = type) === null || _a === void 0 ? void 0 : _a.types) === null || _b === void 0 ? void 0 : _b.find(isPromise);
            if (!base) {
                // unreachable due to the isInput check
                throw new Error(`Input type union must include a Promise: ${this.formatErrorContext(context)} has type '${this.checker.typeToString(type)}'`);
            }
            const innerType = this.unwrapTypeReference(context, base);
            return this.analyzeType(Object.assign(Object.assign({}, context), { inputOutput: InputOutput.Input }), innerType, location, optional, docString);
        }
        else if (isOutput(type)) {
            type = unwrapOutputIntersection(type);
            // Grab the inner type of the OutputInstance<T> type, and then
            // recurse, passing through the optional flag. The type can now not
            // be plain anymore, since it's wrapped in an output.
            const innerType = this.unwrapTypeReference(context, type);
            return this.analyzeType(Object.assign(Object.assign({}, context), { inputOutput: InputOutput.Output }), innerType, location, optional, docString);
        }
        else if (isAny(type)) {
            const $ref = "pulumi.json#/Any";
            const prop = { $ref };
            if (optional) {
                prop.optional = true;
            }
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isAsset(type)) {
            const $ref = "pulumi.json#/Asset";
            const prop = { $ref };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isArchive(type)) {
            const $ref = "pulumi.json#/Archive";
            const prop = { $ref };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isResourceReference(type, this.checker)) {
            throw new Error(`Resource references are not supported yet: ${this.formatErrorContext(context)} has type '${this.checker.typeToString(type)}'`);
        }
        else if (type.isClassOrInterface()) {
            // This is a complex type, create a typedef and then reference it in
            // the PropertyDefinition.
            const name = (_c = type.getSymbol()) === null || _c === void 0 ? void 0 : _c.escapedName;
            if (!name) {
                throw new Error(`Class or interface has no name: ${this.formatErrorContext(context)} has type '${this.checker.typeToString(type)}'`);
            }
            if (this.typeDefinitions[name]) {
                // Type already exists, just reference it and we're done.
                const refProp = { $ref: `#/types/${this.providerName}:index:${name}` };
                if (optional) {
                    refProp.optional = true;
                }
                if (context.inputOutput === InputOutput.Neither) {
                    refProp.plain = true;
                }
                return refProp;
            }
            // Immediately add an empty type definition, so that it can be
            // referenced recursively, then analyze the properties.
            this.typeDefinitions[name] = { name, properties: {} };
            if (this.docStrings[name]) {
                this.typeDefinitions[name].description = this.docStrings[name];
            }
            const typeContext = Object.assign(Object.assign({}, context), { typeName: name });
            const properties = this.analyzeSymbols(typeContext, type.getProperties(), location);
            this.typeDefinitions[name].properties = properties;
            const $ref = `#/types/${this.providerName}:index:${name}`;
            const prop = { $ref };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isArrayType(type)) {
            const prop = { type: "array" };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            const typeArguments = type.typeArguments;
            if (!typeArguments || typeArguments.length !== 1) {
                throw new Error(`Expected exactly one type argument in '${this.checker.typeToString(type)}': ${this.formatErrorContext(context)} has ${(typeArguments === null || typeArguments === void 0 ? void 0 : typeArguments.length) || 0} type arguments`);
            }
            const innerType = typeArguments[0];
            prop.items = this.analyzeType(Object.assign(Object.assign({}, context), { property: `${context.property}[]`, inputOutput: context.inputOutput === InputOutput.Output ? InputOutput.Output : InputOutput.Neither }), innerType, location, false /* optional */);
            if (docString) {
                prop.description = docString;
            }
            return prop;
        }
        else if (isMapType(type, this.checker)) {
            const prop = { type: "object" };
            if (optional) {
                prop.optional = true;
            }
            if (context.inputOutput === InputOutput.Neither) {
                prop.plain = true;
            }
            // We got { [key: string]: <indexInfo.type> }
            const indexInfo = this.checker.getIndexInfoOfType(type, ts.IndexKind.String);
            if (!indexInfo) {
                // We can't actually get here because isMapType checks for indexInfo
                throw new Error(`Map type has no index info`);
            }
            if (docString) {
                prop.description = docString;
            }
            prop.additionalProperties = this.analyzeType(Object.assign(Object.assign({}, context), { property: `${context.property} values` }), indexInfo.type, location, false);
            return prop;
        }
        else if (isOptionalType(type, this.checker)) {
            const unionType = type;
            const nonUndefinedType = unionType.types.find((t) => !(t.flags & ts.TypeFlags.Undefined));
            if (!nonUndefinedType) {
                throw new Error(`Expected exactly one type to not be undefined: ${this.formatErrorContext(context)} has type '${this.checker.typeToString(type)}'`);
            }
            return this.analyzeType(context, nonUndefinedType, location, true, docString);
        }
        else if (type.isUnion()) {
            throw new Error(`Union types are not supported for ${this.formatErrorContext(context)}: type '${this.checker.typeToString(type)}'`);
        }
        else if (type.isIntersection()) {
            throw new Error(`Intersection types are not supported for ${this.formatErrorContext(context)}: type '${this.checker.typeToString(type)}'`);
        }
        throw new Error(`Unsupported type for ${this.formatErrorContext(context)}: type '${this.checker.typeToString(type)}'`);
    }
    unwrapTypeReference(context, type) {
        let typeArguments = type.typeArguments;
        if (!typeArguments) {
            typeArguments = type.aliasTypeArguments;
        }
        if (!typeArguments || typeArguments.length !== 1) {
            throw new Error(`Expected exactly one type argument in '${this.checker.typeToString(type)}': ${this.formatErrorContext(context)} has ${(typeArguments === null || typeArguments === void 0 ? void 0 : typeArguments.length) || 0} type arguments`);
        }
        const innerType = typeArguments[0];
        return innerType;
    }
    formatErrorContext(context) {
        const parts = [];
        parts.push(`component '${context.component}'`);
        if (context.property) {
            let propType = "property";
            if (context.inputOutput !== undefined) {
                if (context.inputOutput === InputOutput.Input) {
                    propType = "input";
                }
                else if (context.inputOutput === InputOutput.Output) {
                    propType = "output";
                }
            }
            parts.push(propType);
            let propName = context.property;
            if (context.typeName) {
                propName = `${context.typeName}.${propName}`;
            }
            parts.push(`'${propName}'`);
        }
        return parts.join(" ");
    }
}
exports.Analyzer = Analyzer;
function isOptional(symbol) {
    return (symbol.flags & ts.SymbolFlags.Optional) === ts.SymbolFlags.Optional;
}
function isOptionalType(type, checker) {
    if (!(type.flags & ts.TypeFlags.Union)) {
        return false;
    }
    const unionType = type;
    // We only support union types with two types, one of which must be undefined
    if (!unionType.types || unionType.types.length !== 2) {
        return false;
    }
    // Check if one of the types in the union is undefined
    return unionType.types.some((t) => t.flags & ts.TypeFlags.Undefined || t.flags & ts.TypeFlags.Void);
}
function isInterface(symbol) {
    return (symbol.flags & ts.SymbolFlags.Interface) === ts.SymbolFlags.Interface;
}
function isPropertyDeclaration(symbol) {
    return (symbol.flags & ts.SymbolFlags.Property) === ts.SymbolFlags.Property;
}
function isNumber(type) {
    return (type.flags & ts.TypeFlags.Number) === ts.TypeFlags.Number;
}
function isString(type) {
    return (type.flags & ts.TypeFlags.String) === ts.TypeFlags.String;
}
function isBoolean(type) {
    return (type.flags & ts.TypeFlags.Boolean) === ts.TypeFlags.Boolean;
}
function isAny(type) {
    return (type.flags & ts.TypeFlags.Any) === ts.TypeFlags.Any;
}
function isSimpleType(type) {
    return isNumber(type) || isString(type) || isBoolean(type);
}
function isMapType(type, checker) {
    const indexInfo = checker.getIndexInfoOfType(type, ts.IndexKind.String);
    return indexInfo !== undefined;
}
function isArrayType(type) {
    var _a;
    return (type.flags & ts.TypeFlags.Object) === ts.TypeFlags.Object && ((_a = type.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName) === "Array";
}
function isPromise(type) {
    if (!(type.flags & ts.TypeFlags.Object)) {
        return false;
    }
    const symbol = type.symbol;
    if (!symbol) {
        return false;
    }
    return symbol.name === "Promise";
}
function isOutput(type) {
    var _a;
    // In sdk/nodejs/output.ts we define Output as:
    //
    //   export type Output<T> = OutputInstance<T> & Lifted<T>;
    //
    // Depending on T, we might have an OutputInstance<T> because Lifted<T>
    // does not add anything to the resulting type, or we get the
    // intersection. In the latter case, we want to find the
    // OutputInstance<T> within the intersection.
    if (type.isIntersection()) {
        for (const t of type.types) {
            if (isOutput(t)) {
                return true;
            }
        }
    }
    let symbol = type.getSymbol();
    if (!symbol) {
        symbol = type.aliasSymbol;
    }
    const matchesName = (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "OutputInstance" || (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "Output";
    const sourceFile = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0].getSourceFile();
    const matchesSourceFile = (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("output.ts")) || (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("output.d.ts"));
    return !!matchesName && !!matchesSourceFile;
}
function isAsset(type) {
    var _a;
    const symbol = type.getSymbol();
    const matchesName = (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "Asset";
    const sourceFile = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0].getSourceFile();
    const matchesSourceFile = (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("asset.ts")) || (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("asset.d.ts"));
    return !!matchesName && !!matchesSourceFile;
}
function isArchive(type) {
    var _a;
    const symbol = type.getSymbol();
    const matchesName = (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "Archive";
    const sourceFile = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0].getSourceFile();
    const matchesSourceFile = (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("archive.ts")) || (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("archive.d.ts"));
    return !!matchesName && !!matchesSourceFile;
}
function unwrapOutputIntersection(type) {
    // Output<T> is an intersection type `OutputInstance<T> & Lifted<T>`, and
    // we want to find the `OutputInstance<T>` within the intersection for
    // further analysis.
    // Depending on `T`, TypeScript sometimes infers Output<T> directly as
    // `OutputInstance<T>`, dropping the `Lifted<T>` part.
    if (type.isIntersection()) {
        for (const t of type.types) {
            if (isOutput(t)) {
                return t;
            }
        }
    }
    return type;
}
/**
 * An input type is a union of Output<T>, Promise<T>, and T.
 */
function isInput(type) {
    if (!type.isUnion()) {
        return false;
    }
    let hasOutput = false;
    let hasPromise = false;
    let hasOther = false;
    for (const t of type.types) {
        if (isOutput(t)) {
            hasOutput = true;
        }
        else if (isPromise(t)) {
            hasPromise = true;
        }
        else {
            hasOther = true;
        }
    }
    return hasOutput && hasPromise && hasOther;
}
function isResourceReference(type, checker) {
    if (!type.isClass()) {
        return false;
    }
    return checker.getBaseTypes(type).some((baseType) => {
        var _a;
        const symbol = baseType.getSymbol();
        const matchesName = (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "CustomResource" ||
            (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "ComponentResource" ||
            (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) === "Resource";
        const sourceFile = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0].getSourceFile();
        const matchesSourceFile = (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("resource.ts")) || (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.fileName.endsWith("resource.d.ts"));
        return (matchesName && matchesSourceFile) || isResourceReference(baseType, checker);
    });
}
function tsTypeToPropertyType(type) {
    var _a;
    if (isNumber(type)) {
        return "number";
    }
    else if (isString(type)) {
        return "string";
    }
    else if (isBoolean(type)) {
        return "boolean";
    }
    throw new Error(`Unsupported type '${(_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name}'`);
}
function symbolTableToSymbols(table) {
    const symbols = [];
    table.forEach((symbol) => {
        symbols.push(symbol);
    });
    return symbols;
}
//# sourceMappingURL=analyzer.js.map