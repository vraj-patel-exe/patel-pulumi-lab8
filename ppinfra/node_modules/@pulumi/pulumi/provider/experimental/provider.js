"use strict";
// Copyright 2025-2025, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path = __importStar(require("path"));
const output_1 = require("../../output");
const server_1 = require("../server");
const schema_1 = require("./schema");
const analyzer_1 = require("./analyzer");
function getInputsFromOutputs(resource) {
    const result = {};
    for (const key of Object.keys(resource)) {
        const value = resource[key];
        if (output_1.Output.isInstance(value)) {
            result[key] = value;
        }
    }
    return result;
}
class ComponentProvider {
    constructor(dir) {
        this.dir = dir;
        const absDir = path.resolve(dir);
        const packStr = fs_1.readFileSync(`${absDir}/package.json`, { encoding: "utf-8" });
        this.packageJSON = JSON.parse(packStr);
        this.version = this.packageJSON.version;
        this.path = absDir;
        this.analyzer = new analyzer_1.Analyzer(this.path, this.packageJSON.name);
    }
    static validateResourceType(packageName, resourceType) {
        const parts = resourceType.split(":");
        if (parts.length !== 3) {
            throw new Error(`Invalid resource type ${resourceType}`);
        }
        if (parts[0] !== packageName) {
            throw new Error(`Invalid package name ${parts[0]}, expected '${packageName}'`);
        }
        // We might want to relax this limitation, but for now we only support the "index" module.
        if (parts[1] !== "index" && parts[1] !== "") {
            throw new Error(`Invalid module '${parts[1]}' in resource type '${resourceType}', expected 'index' or empty string`);
        }
        if (parts[2].length === 0) {
            throw new Error(`Empty resource name in resource type '${resourceType}'`);
        }
    }
    getSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            const { components, typeDefinitions } = this.analyzer.analyze();
            const schema = schema_1.generateSchema(this.packageJSON, components, typeDefinitions);
            return JSON.stringify(schema);
        });
    }
    construct(name, type, inputs, options) {
        return __awaiter(this, void 0, void 0, function* () {
            ComponentProvider.validateResourceType(this.packageJSON.name, type);
            const componentName = type.split(":")[2];
            const ComponentClass = yield this.analyzer.findComponent(componentName);
            // The ComponentResource base class has a 4 argument constructor, but
            // the user defined component has a 3 argument constructor without the
            // typestring.
            // @ts-ignore
            const instance = new ComponentClass(name, inputs, options);
            return {
                urn: instance.urn,
                state: getInputsFromOutputs(instance),
            };
        });
    }
}
exports.ComponentProvider = ComponentProvider;
function componentProviderHost(dirname) {
    const args = process.argv.slice(2);
    // If dirname is not provided, get it from the call stack
    if (!dirname) {
        // Get the stack trace
        const stack = new Error().stack;
        // Parse the stack to get the caller's file
        // Stack format is like:
        // Error
        //     at componentProviderHost (.../src/index.ts:3:16)
        //     at Object.<anonymous> (.../caller/index.ts:4:1)
        const callerLine = stack === null || stack === void 0 ? void 0 : stack.split("\n")[2];
        const match = callerLine === null || callerLine === void 0 ? void 0 : callerLine.match(/\((.+):[0-9]+:[0-9]+\)/);
        if (match === null || match === void 0 ? void 0 : match[1]) {
            dirname = path.dirname(match[1]);
        }
        else {
            throw new Error("Could not determine caller directory");
        }
    }
    const prov = new ComponentProvider(dirname);
    return server_1.main(prov, args);
}
exports.componentProviderHost = componentProviderHost;
//# sourceMappingURL=provider.js.map