"use strict";
// Copyright 2016-2021, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = __importStar(require("@grpc/grpc-js"));
const query = __importStar(require("@pulumi/query"));
const log = __importStar(require("../log"));
const utils = __importStar(require("../utils"));
const output_1 = require("../output");
const resource_1 = require("../resource");
const dependsOn_1 = require("./dependsOn");
const debuggable_1 = require("./debuggable");
const invoke_1 = require("./invoke");
const state_1 = require("./state");
const errors_1 = require("../errors");
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const gstruct = __importStar(require("google-protobuf/google/protobuf/struct_pb"));
const aliasproto = __importStar(require("../proto/alias_pb"));
const resproto = __importStar(require("../proto/resource_pb"));
const sourceproto = __importStar(require("../proto/source_pb"));
function marshalSourcePosition(sourcePosition) {
    if (sourcePosition === undefined) {
        return undefined;
    }
    const pos = new sourceproto.SourcePosition();
    pos.setUri(sourcePosition.uri);
    pos.setLine(sourcePosition.line);
    pos.setColumn(sourcePosition.column);
    return pos;
}
/**
 * Get an existing resource's state from the engine.
 */
function getResource(res, parent, props, custom, urn) {
    // Extract the resource type from the URN.
    const urnParts = urn.split("::");
    const qualifiedType = urnParts[2];
    const urnName = urnParts[3];
    const type = qualifiedType.split("$").pop();
    const label = `resource:urn=${urn}`;
    log.debug(`Getting resource: urn=${urn}`);
    // Wait for all values to be available, and then perform the RPC.
    const done = settings_1.rpcKeepAlive();
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, parent, custom, false, props, {});
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync
        .then((resop) => __awaiter(this, void 0, void 0, function* () {
        const inputs = yield rpc_1.serializeProperties(label, { urn });
        const req = new resproto.ResourceInvokeRequest();
        req.setTok("pulumi:pulumi:getResource");
        req.setArgs(gstruct.Struct.fromJavaScript(inputs));
        req.setProvider("");
        req.setVersion("");
        req.setAcceptresources(!utils.disableResourceReferences);
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.getResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp = {};
            let err;
            try {
                if (monitor) {
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.invoke(req, (rpcError, innerResponse) => {
                        log.debug(`getResource Invoke RPC finished: err: ${rpcError}, resp: ${innerResponse}`);
                        if (rpcError) {
                            if (rpcError.code === grpc.status.UNAVAILABLE ||
                                rpcError.code === grpc.status.CANCELLED) {
                                err = rpcError;
                                settings_1.terminateRpcs();
                                rpcError.message = "Resource monitor is terminating";
                                preallocError.code = rpcError.code;
                            }
                            preallocError.message = `failed to get resource:urn=${urn}: ${rpcError.message}`;
                            reject(new Error(rpcError.details));
                        }
                        else {
                            resolve(innerResponse);
                        }
                    })), opLabel);
                    // If the invoke failed, raise an error
                    const failures = resp.getFailuresList();
                    if (failures === null || failures === void 0 ? void 0 : failures.length) {
                        let reasons = "";
                        for (let i = 0; i < failures.length; i++) {
                            if (reasons !== "") {
                                reasons += "; ";
                            }
                            reasons += `${failures[i].getReason()} (${failures[i].getProperty()})`;
                        }
                        throw new Error(`getResource Invoke failed: ${reasons}`);
                    }
                    // Otherwise, return the response.
                    const m = resp.getReturn().getFieldsMap();
                    resp = {
                        urn: m.get("urn").toJavaScript(),
                        id: m.get("id").toJavaScript() || undefined,
                        state: m.get("state").getStructValue(),
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    urn: "",
                    id: undefined,
                    state: undefined,
                };
            }
            resop.resolveURN(resp.urn, err);
            // Note: 'id || undefined' is intentional.  We intentionally collapse falsy values to
            // undefined so that later parts of our system don't have to deal with values like 'null'.
            if (resop.resolveID) {
                const id = resp.id || undefined;
                resop.resolveID(id, id !== undefined, err);
            }
            yield resolveOutputs(res, type, urnName, props, resp.state, {}, resop.resolvers, err);
            done();
        }));
    }))
        .catch((err) => {
        done();
        throw err;
    }), label);
}
exports.getResource = getResource;
/**
 * Reads an existing custom resource's state from the resource monitor.  Note
 * that resources read in this way will not be part of the resulting stack's
 * state, as they are presumed to belong to another.
 */
function readResource(res, parent, t, name, props, opts, sourcePosition, packageRef) {
    if (!opts.id) {
        throw new Error("Cannot read resource whose options are lacking an ID value");
    }
    const id = output_1.output(opts.id).promise(true);
    const label = `resource:${name}[${t}]#...`;
    log.debug(`Reading resource: t=${t}, name=${name}`);
    // Wait for all values to be available, and then perform the RPC.
    const done = settings_1.rpcKeepAlive();
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, parent, true, false, props, opts);
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync
        .then((resop) => __awaiter(this, void 0, void 0, function* () {
        const resolvedID = yield rpc_1.serializeProperty(label, yield id, new Set(), { keepOutputValues: false });
        log.debug(`ReadResource RPC prepared: id=${resolvedID}, t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        let packageRefStr = undefined;
        if (packageRef !== undefined) {
            packageRefStr = yield packageRef;
            if (packageRefStr !== undefined) {
                // If we have a package reference we can clear some of the resource options
                opts.version = undefined;
                opts.pluginDownloadURL = undefined;
            }
        }
        // Create a resource request and do the RPC.
        const req = new resproto.ReadResourceRequest();
        req.setType(t);
        req.setName(name);
        req.setId(resolvedID);
        req.setParent(resop.parentURN || "");
        req.setProvider(resop.providerRef || "");
        req.setProperties(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setDependenciesList(Array.from(resop.allDirectDependencyURNs));
        req.setVersion(opts.version || "");
        req.setPlugindownloadurl(opts.pluginDownloadURL || "");
        req.setAcceptsecrets(true);
        req.setAcceptresources(!utils.disableResourceReferences);
        req.setAdditionalsecretoutputsList(opts.additionalSecretOutputs || []);
        req.setSourceposition(marshalSourcePosition(sourcePosition));
        req.setPackageref(packageRefStr || "");
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.readResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp = {};
            let err;
            try {
                if (monitor) {
                    // If we're attached to the engine, make an RPC call and wait for it to resolve.
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.readResource(req, (rpcError, innerResponse) => {
                        log.debug(`ReadResource RPC finished: ${label}; err: ${rpcError}, resp: ${innerResponse}`);
                        if (rpcError) {
                            if (rpcError.code === grpc.status.UNAVAILABLE ||
                                rpcError.code === grpc.status.CANCELLED) {
                                err = rpcError;
                                settings_1.terminateRpcs();
                                rpcError.message = "Resource monitor is terminating";
                                preallocError.code = rpcError.code;
                            }
                            preallocError.message = `failed to read resource #${resolvedID} '${name}' [${t}]: ${rpcError.message}`;
                            reject(preallocError);
                        }
                        else {
                            resolve(innerResponse);
                        }
                    })), opLabel);
                }
                else {
                    // If we aren't attached to the engine, in test mode, mock up a fake response for testing purposes.
                    const mockurn = yield resource_1.createUrn(req.getName(), req.getType(), req.getParent()).promise();
                    resp = {
                        getUrn: () => mockurn,
                        getProperties: () => req.getProperties(),
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    getUrn: () => "",
                    getProperties: () => undefined,
                };
            }
            // Now resolve everything: the URN, the ID (supplied as input), and the output properties.
            resop.resolveURN(resp.getUrn(), err);
            resop.resolveID(resolvedID, resolvedID !== undefined, err);
            yield resolveOutputs(res, t, name, props, resp.getProperties(), {}, resop.resolvers, err);
            done();
        }));
    }))
        .catch((err) => {
        done();
        throw err;
    }), label);
}
exports.readResource = readResource;
function getParentURN(parent) {
    if (resource_1.Resource.isInstance(parent)) {
        return parent.urn;
    }
    return output_1.output(parent);
}
function mapAliasesForRequest(aliases, parentURN) {
    if (aliases === undefined) {
        return Promise.resolve([]);
    }
    return Promise.all(aliases.map((a) => __awaiter(this, void 0, void 0, function* () {
        const newAlias = new aliasproto.Alias();
        if (typeof a === "string") {
            newAlias.setUrn(a);
        }
        else {
            const newAliasSpec = new aliasproto.Alias.Spec();
            const name = a.name === undefined ? undefined : yield output_1.output(a.name).promise();
            const type = a.type === undefined ? undefined : yield output_1.output(a.type).promise();
            const stack = a.stack === undefined ? undefined : yield output_1.output(a.stack).promise();
            const project = a.project === undefined ? undefined : yield output_1.output(a.project).promise();
            newAliasSpec.setName(name || "");
            newAliasSpec.setType(type || "");
            newAliasSpec.setStack(stack || "");
            newAliasSpec.setProject(project || "");
            if (a.hasOwnProperty("parent")) {
                if (a.parent === undefined) {
                    newAliasSpec.setNoparent(true);
                }
                else {
                    const aliasParentUrn = getParentURN(a.parent);
                    const urn = yield aliasParentUrn.promise();
                    if (urn !== undefined) {
                        newAliasSpec.setParenturn(urn);
                    }
                }
            }
            else if (parentURN) {
                // If a parent isn't specified for the alias and the resource has a parent,
                // pass along the resource's parent in the alias spec.
                // It shouldn't be necessary to do this because the engine should fill-in the
                // resource's parent if one wasn't specified for the alias.
                // However, some older versions of the CLI don't do this correctly, and this
                // SDK has always passed along the parent in this way, so we continue doing it
                // to maintain compatibility with these versions of the CLI.
                newAliasSpec.setParenturn(parentURN);
            }
            newAlias.setSpec(newAliasSpec);
        }
        return newAlias;
    })));
}
exports.mapAliasesForRequest = mapAliasesForRequest;
/**
 * registerResource registers a new resource object with a given type `t` and
 * `name`. It returns the auto-generated URN and the ID that will resolve after
 * the deployment has completed.  All properties will be initialized to property
 * objects that the registration operation will resolve at the right time (or
 * remain unresolved for deployments).
 */
function registerResource(res, parent, t, name, custom, remote, newDependency, props, opts, sourcePosition, packageRef) {
    const label = `resource:${name}[${t}]`;
    log.debug(`Registering resource: t=${t}, name=${name}, custom=${custom}, remote=${remote}`);
    // Wait for all values to be available, and then perform the RPC.
    const done = settings_1.rpcKeepAlive();
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, parent, custom, remote, props, opts, t, name);
    // In order to present a useful stack trace if an error does occur, we preallocate potential
    // errors here. V8 captures a stack trace at the moment an Error is created and this stack
    // trace will lead directly to user code. Throwing in `runAsyncResourceOp` results in an Error
    // with a non-useful stack trace.
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync
        .then((resop) => __awaiter(this, void 0, void 0, function* () {
        log.debug(`RegisterResource RPC prepared: t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        yield settings_1.awaitStackRegistrations();
        const callbacks = [];
        if (opts.transforms !== undefined && opts.transforms.length > 0) {
            if (!state_1.getStore().supportsTransforms) {
                throw new Error("The Pulumi CLI does not support transforms. Please update the Pulumi CLI");
            }
            const callbackServer = settings_1.getCallbacks();
            if (callbackServer === undefined) {
                throw new Error("Callback server could not initialize");
            }
            for (const transform of opts.transforms) {
                callbacks.push(yield callbackServer.registerTransform(transform));
            }
        }
        // If we have a package reference, we need to wait for it to resolve.
        let packageRefStr = undefined;
        if (packageRef !== undefined) {
            packageRefStr = yield packageRef;
            if (packageRefStr !== undefined) {
                // If we have a package reference we can clear some of the resource options
                opts.version = undefined;
                opts.pluginDownloadURL = undefined;
            }
        }
        const req = new resproto.RegisterResourceRequest();
        req.setPackageref(packageRefStr || "");
        req.setType(t);
        req.setName(name);
        req.setParent(resop.parentURN || "");
        req.setCustom(custom);
        req.setObject(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setProtect(opts.protect || false);
        req.setProvider(resop.providerRef || "");
        req.setDependenciesList(Array.from(resop.allDirectDependencyURNs));
        req.setDeletebeforereplace(opts.deleteBeforeReplace || false);
        req.setDeletebeforereplacedefined(opts.deleteBeforeReplace !== undefined);
        req.setIgnorechangesList(opts.ignoreChanges || []);
        req.setVersion(opts.version || "");
        req.setAcceptsecrets(true);
        req.setAcceptresources(!utils.disableResourceReferences);
        req.setAdditionalsecretoutputsList(opts.additionalSecretOutputs || []);
        if (resop.monitorSupportsStructuredAliases) {
            const aliasesList = yield mapAliasesForRequest(resop.aliases, resop.parentURN);
            req.setAliasesList(aliasesList);
        }
        else {
            const urns = new Array();
            resop.aliases.forEach((v) => {
                if (typeof v === "string") {
                    urns.push(v);
                }
            });
            req.setAliasurnsList(urns);
        }
        req.setImportid(resop.import || "");
        req.setSupportspartialvalues(true);
        req.setRemote(remote);
        req.setReplaceonchangesList(opts.replaceOnChanges || []);
        req.setPlugindownloadurl(opts.pluginDownloadURL || "");
        req.setRetainondelete(opts.retainOnDelete || false);
        req.setDeletedwith(resop.deletedWithURN || "");
        req.setAliasspecs(true);
        req.setSourceposition(marshalSourcePosition(sourcePosition));
        req.setTransformsList(callbacks);
        req.setSupportsresultreporting(true);
        if (resop.deletedWithURN && !state_1.getStore().supportsDeletedWith) {
            throw new Error("The Pulumi CLI does not support the DeletedWith option. Please update the Pulumi CLI.");
        }
        const customTimeouts = new resproto.RegisterResourceRequest.CustomTimeouts();
        if (opts.customTimeouts != null) {
            customTimeouts.setCreate(opts.customTimeouts.create || "");
            customTimeouts.setUpdate(opts.customTimeouts.update || "");
            customTimeouts.setDelete(opts.customTimeouts.delete || "");
        }
        req.setCustomtimeouts(customTimeouts);
        const propertyDependencies = req.getPropertydependenciesMap();
        for (const [key, resourceURNs] of resop.propertyToDirectDependencyURNs) {
            const deps = new resproto.RegisterResourceRequest.PropertyDependencies();
            deps.setUrnsList(Array.from(resourceURNs));
            propertyDependencies.set(key, deps);
        }
        const providerRefs = req.getProvidersMap();
        for (const [key, ref] of resop.providerRefs) {
            providerRefs.set(key, ref);
        }
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.registerResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            let resp = {};
            let err;
            try {
                if (monitor) {
                    // If we're running with an attachment to the engine, perform the operation.
                    resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResource(req, (rpcErr, innerResponse) => {
                        if (rpcErr) {
                            err = rpcErr;
                            // If the monitor is unavailable, it is in the process of shutting down or has already
                            // shut down. Don't emit an error and don't do any more RPCs, just exit.
                            if (rpcErr.code === grpc.status.UNAVAILABLE ||
                                rpcErr.code === grpc.status.CANCELLED) {
                                // Re-emit the message
                                settings_1.terminateRpcs();
                                rpcErr.message = "Resource monitor is terminating";
                                preallocError.code = rpcErr.code;
                            }
                            // Node lets us hack the message as long as we do it before accessing the `stack` property.
                            log.debug(`RegisterResource RPC finished: ${label}; err: ${rpcErr}, resp: ${innerResponse}`);
                            preallocError.message = `failed to register new resource ${name} [${t}]: ${rpcErr.message}`;
                            reject(preallocError);
                        }
                        else {
                            log.debug(`RegisterResource RPC finished: ${label}; err: ${rpcErr}, resp: ${innerResponse}`);
                            resolve(innerResponse);
                        }
                    })), opLabel);
                }
                else {
                    // If we aren't attached to the engine, in test mode, mock up a fake response for testing purposes.
                    const mockurn = yield resource_1.createUrn(req.getName(), req.getType(), req.getParent()).promise();
                    resp = {
                        getUrn: () => mockurn,
                        getId: () => undefined,
                        getObject: () => req.getObject(),
                        getPropertydependenciesMap: () => undefined,
                        getResult: () => 0,
                    };
                }
            }
            catch (e) {
                err = e;
                resp = {
                    getUrn: () => "",
                    getId: () => undefined,
                    getObject: () => req.getObject(),
                    getPropertydependenciesMap: () => undefined,
                    getResult: () => 0,
                };
            }
            resop.resolveURN(resp.getUrn(), err);
            // Note: 'id || undefined' is intentional.  We intentionally collapse falsy values to
            // undefined so that later parts of our system don't have to deal with values like 'null'.
            if (resop.resolveID) {
                const id = resp.getId() || undefined;
                resop.resolveID(id, id !== undefined, err);
            }
            const deps = {};
            const rpcDeps = resp.getPropertydependenciesMap();
            if (rpcDeps) {
                for (const [k, propertyDeps] of resp.getPropertydependenciesMap().entries()) {
                    const urns = propertyDeps.getUrnsList();
                    deps[k] = urns.map((urn) => newDependency(urn));
                }
            }
            // Now resolve the output properties.
            const keepUnknowns = resp.getResult() !== resproto.Result.SUCCESS;
            yield resolveOutputs(res, t, name, props, resp.getObject(), deps, resop.resolvers, err, keepUnknowns);
            done();
        }));
    }))
        .catch((err) => {
        // If we fail to prepare the resource, we need to ensure that we still call done to prevent a hang.
        done();
        throw err;
    }), label);
}
exports.registerResource = registerResource;
/**
 * Prepares for an RPC that will manufacture a resource, and hence deals with
 * input and output properties.
 *
 * @internal
 */
function prepareResource(label, res, parent, custom, remote, props, opts, type, name) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Simply initialize the URN property and get prepared to resolve it later on.
        // Note: a resource urn will always get a value, and thus the output property
        // for it can always run .apply calls.
        let resolveURN;
        {
            let resolveValue;
            let rejectValue;
            let resolveIsKnown;
            let rejectIsKnown;
            res.urn = new output_1.Output(res, debuggable_1.debuggablePromise(new Promise((resolve, reject) => {
                resolveValue = resolve;
                rejectValue = reject;
            }), `resolveURN(${label})`), debuggable_1.debuggablePromise(new Promise((resolve, reject) => {
                resolveIsKnown = resolve;
                rejectIsKnown = reject;
            }), `resolveURNIsKnown(${label})`), 
            /*isSecret:*/ Promise.resolve(false), Promise.resolve(res));
            resolveURN = (v, err) => {
                if (err) {
                    if (errors_1.isGrpcError(err)) {
                        if (debuggable_1.debugPromiseLeaks) {
                            console.error("info: skipped rejection in resolveURN");
                        }
                        return;
                    }
                    rejectValue(err);
                    rejectIsKnown(err);
                }
                else {
                    resolveValue(v);
                    resolveIsKnown(true);
                }
            };
        }
        // If a custom resource, make room for the ID property.
        let resolveID;
        if (custom) {
            let resolveValue;
            let rejectValue;
            let resolveIsKnown;
            let rejectIsKnown;
            res.id = new output_1.Output(res, debuggable_1.debuggablePromise(new Promise((resolve, reject) => {
                resolveValue = resolve;
                rejectValue = reject;
            }), `resolveID(${label})`), debuggable_1.debuggablePromise(new Promise((resolve, reject) => {
                resolveIsKnown = resolve;
                rejectIsKnown = reject;
            }), `resolveIDIsKnown(${label})`), Promise.resolve(false), Promise.resolve(res));
            resolveID = (v, isKnown, err) => {
                if (err) {
                    if (errors_1.isGrpcError(err)) {
                        if (debuggable_1.debugPromiseLeaks) {
                            console.error("info: skipped rejection in resolveID");
                        }
                        return;
                    }
                    rejectValue(err);
                    rejectIsKnown(err);
                }
                else {
                    resolveValue(v);
                    resolveIsKnown(isKnown);
                }
            };
        }
        // Now "transfer" all input properties into unresolved Promises on res.  This way,
        // this resource will look like it has all its output properties to anyone it is
        // passed to.  However, those promises won't actually resolve until the registerResource
        // RPC returns
        const resolvers = rpc_1.transferProperties(res, label, props);
        /** IMPORTANT!  We should never await prior to this line, otherwise the Resource will be partly uninitialized. */
        // Before we can proceed, all our dependencies must be finished.
        const explicitDirectDependencies = new Set(yield dependsOn_1.gatherExplicitDependencies(opts.dependsOn));
        // Serialize out all our props to their final values.  In doing so, we'll also collect all
        // the Resources pointed to by any Dependency objects we encounter, adding them to 'propertyDependencies'.
        const [serializedProps, propertyToDirectDependencies] = yield rpc_1.serializeResourceProperties(label, props, {
            // To initially scope the use of this new feature, we only keep output values when
            // remote is true (for multi-lang components, i.e. MLCs).
            keepOutputValues: remote,
            // When remote is true, exclude resource references from 'propertyDependencies'.
            // This way, component providers creating outputs for component inputs based
            // on 'propertyDependencies' won't create outputs for properties that only
            // contain resource references.
            excludeResourceReferencesFromDependencies: remote,
        });
        // Wait for the parent to complete.
        // If no parent was provided, parent to the root resource.
        const parentURN = parent ? yield parent.urn.promise() : undefined;
        let importID;
        if (custom) {
            const customOpts = opts;
            importID = customOpts.import;
        }
        let providerRef;
        let sendProvider = custom;
        if (remote && opts.provider) {
            // If it's a remote component and a provider was specified, only
            // send the provider in the request if the provider's package is
            // the same as the component's package. Otherwise, don't send it
            // because the user specified `provider: someProvider` as shorthand
            // for `providers: [someProvider]`.
            const pkg = resource_1.pkgFromType(type);
            if (pkg && pkg === opts.provider.getPackage()) {
                sendProvider = true;
            }
        }
        if (sendProvider) {
            providerRef = yield resource_1.ProviderResource.register(opts.provider);
        }
        const providerRefs = new Map();
        if (remote || !custom) {
            const componentOpts = opts;
            resource_1.expandProviders(componentOpts);
            // the <ProviderResource[]> casts are safe because expandProviders
            // /always/ leaves providers as an array.
            if (componentOpts.provider !== undefined) {
                if (componentOpts.providers === undefined) {
                    // We still want to do the promotion, so we define providers
                    componentOpts.providers = [componentOpts.provider];
                }
                else if (((_a = componentOpts.providers) === null || _a === void 0 ? void 0 : _a.indexOf(componentOpts.provider)) !== -1) {
                    const pkg = componentOpts.provider.getPackage();
                    const message = `There is a conflict between the 'provider' field (${pkg}) and a member of the 'providers' map'. `;
                    const deprecationd = "This will become an error in a future version. See https://github.com/pulumi/pulumi/issues/8799 for more details";
                    log.warn(message + deprecationd);
                }
                else {
                    componentOpts.providers.push(componentOpts.provider);
                }
            }
            if (componentOpts.providers) {
                for (const provider of componentOpts.providers) {
                    const pref = yield resource_1.ProviderResource.register(provider);
                    if (pref) {
                        providerRefs.set(provider.getPackage(), pref);
                    }
                }
            }
        }
        // Collect the URNs for explicit/implicit dependencies for the engine so that it can understand
        // the dependency graph and optimize operations accordingly.
        // The list of all dependencies (implicit or explicit).
        const allDirectDependencies = new Set(explicitDirectDependencies);
        const exclude = new Set([res]);
        const allDirectDependencyURNs = yield dependsOn_1.getAllTransitivelyReferencedResourceURNs(explicitDirectDependencies, exclude);
        const propertyToDirectDependencyURNs = new Map();
        for (const [propertyName, directDependencies] of propertyToDirectDependencies) {
            addAll(allDirectDependencies, directDependencies);
            const urns = yield dependsOn_1.getAllTransitivelyReferencedResourceURNs(directDependencies, exclude);
            addAll(allDirectDependencyURNs, urns);
            propertyToDirectDependencyURNs.set(propertyName, urns);
        }
        const monitorSupportsStructuredAliases = state_1.getStore().supportsAliasSpecs;
        let computedAliases;
        if (!monitorSupportsStructuredAliases && parent) {
            computedAliases = resource_1.allAliases(opts.aliases || [], name, type, parent, parent.__name);
        }
        else {
            computedAliases = opts.aliases || [];
        }
        // Wait for all aliases.
        const aliases = [];
        const uniqueAliases = new Set();
        for (const alias of computedAliases || []) {
            const aliasVal = yield output_1.output(alias).promise();
            if (!uniqueAliases.has(aliasVal)) {
                uniqueAliases.add(aliasVal);
                aliases.push(aliasVal);
            }
        }
        const deletedWithURN = (opts === null || opts === void 0 ? void 0 : opts.deletedWith) ? yield opts.deletedWith.urn.promise() : undefined;
        return {
            resolveURN: resolveURN,
            resolveID: resolveID,
            resolvers: resolvers,
            serializedProps: serializedProps,
            parentURN: parentURN,
            providerRef: providerRef,
            providerRefs: providerRefs,
            allDirectDependencyURNs: allDirectDependencyURNs,
            propertyToDirectDependencyURNs: propertyToDirectDependencyURNs,
            aliases: aliases,
            import: importID,
            monitorSupportsStructuredAliases,
            deletedWithURN,
        };
    });
}
exports.prepareResource = prepareResource;
function addAll(to, from) {
    for (const val of from) {
        to.add(val);
    }
}
/**
 * Finishes a resource creation RPC operation by resolving its outputs to the
 * resulting RPC payload.
 */
function resolveOutputs(res, t, name, props, outputs, deps, resolvers, err, keepUnknowns) {
    return __awaiter(this, void 0, void 0, function* () {
        // Produce a combined set of property states, starting with inputs and then applying
        // outputs.  If the same property exists in the inputs and outputs states, the output wins.
        const allProps = {};
        if (outputs) {
            Object.assign(allProps, rpc_1.deserializeProperties(outputs, keepUnknowns));
        }
        const label = `resource:${name}[${t}]#...`;
        if (!settings_1.isDryRun() || settings_1.isLegacyApplyEnabled()) {
            for (const key of Object.keys(props)) {
                if (!allProps.hasOwnProperty(key)) {
                    // input prop the engine didn't give us a final value for.  Just use the value passed into the resource
                    // after round-tripping it through serialization. We do the round-tripping primarily s.t. we ensure that
                    // Output values are handled properly w.r.t. unknowns.
                    const inputProp = yield rpc_1.serializeProperty(label, props[key], new Set(), { keepOutputValues: false });
                    if (inputProp === undefined) {
                        continue;
                    }
                    allProps[key] = rpc_1.deserializeProperty(inputProp, keepUnknowns);
                }
            }
        }
        rpc_1.resolveProperties(res, resolvers, t, name, allProps, deps, err, keepUnknowns);
    });
}
/**
 * Completes a resource registration, attaching an optional set of computed
 * outputs.
 */
function registerResourceOutputs(res, outputs) {
    // Now run the operation. Note that we explicitly do not serialize output registration with
    // respect to other resource operations, as outputs may depend on properties of other resources
    // that will not resolve until later turns. This would create a circular promise chain that can
    // never resolve.
    const opLabel = `monitor.registerResourceOutputs(...)`;
    const done = settings_1.rpcKeepAlive();
    runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
        try {
            // The registration could very well still be taking place, so we will need to wait for its URN.
            // Additionally, the output properties might have come from other resources, so we must await those too.
            const urn = yield res.urn.promise();
            const resolved = yield rpc_1.serializeProperties(opLabel, { outputs });
            const outputsObj = gstruct.Struct.fromJavaScript(resolved.outputs);
            log.debug(`RegisterResourceOutputs RPC prepared: urn=${urn}` +
                (settings_1.excessiveDebugOutput ? `, outputs=${JSON.stringify(outputsObj)}` : ``));
            // Fetch the monitor and make an RPC request.
            const monitor = settings_1.getMonitor();
            if (monitor) {
                const req = new resproto.RegisterResourceOutputsRequest();
                req.setUrn(urn);
                req.setOutputs(outputsObj);
                const label = `monitor.registerResourceOutputs(${urn}, ...)`;
                yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResourceOutputs(req, (err, innerResponse) => {
                    log.debug(`RegisterResourceOutputs RPC finished: urn=${urn}; ` +
                        `err: ${err}, resp: ${innerResponse}`);
                    if (err) {
                        // If the monitor is unavailable, it is in the process of shutting down or has already
                        // shut down. Don't emit an error and don't do any more RPCs, just exit.
                        if (err.code === grpc.status.UNAVAILABLE ||
                            err.code === grpc.status.CANCELLED) {
                            settings_1.terminateRpcs();
                            err.message = "Resource monitor is terminating";
                        }
                        reject(err);
                    }
                    else {
                        log.debug(`RegisterResourceOutputs RPC finished: urn=${urn}; ` +
                            `err: ${err}, resp: ${innerResponse}`);
                        resolve();
                    }
                })), label);
            }
        }
        finally {
            done();
        }
    }), false);
}
exports.registerResourceOutputs = registerResourceOutputs;
function isAny(o) {
    return true;
}
/**
 * Returns the resource outputs (if any) for a stack, or an error if the stack
 * cannot be found. Resources are retrieved from the latest stack snapshot,
 * which may include ongoing updates. For example:
 *
 * ```typescript
 * const buckets = pulumi.runtime.listResourceOutput(aws.s3.Bucket.isInstance);
 * ```
 *
 * @param stackName
 *  Name of stack to retrieve resource outputs for. Defaults to the current stack.
 * @param typeFilter
 *  A [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)
 *  that specifies which resource types to list outputs of.
 */
function listResourceOutputs(typeFilter, stackName) {
    if (typeFilter === undefined) {
        typeFilter = isAny;
    }
    return query
        .from(invoke_1.invoke("pulumi:pulumi:readStackResourceOutputs", {
        stackName: stackName || settings_1.getStack(),
    }).then(({ outputs }) => utils.values(outputs)))
        .map(({ type: typ, outputs }) => {
        return Object.assign(Object.assign({}, outputs), { __pulumiType: typ });
    })
        .filter(typeFilter);
}
exports.listResourceOutputs = listResourceOutputs;
/**
 * resourceChain is used to serialize all resource requests.  If we don't do
 * this, all resource operations will be entirely asynchronous, meaning the
 * dataflow graph that results will determine ordering of operations.  This
 * causes problems with some resource providers, so for now we will serialize
 * all of them.  The issue pulumi/pulumi#335 tracks coming up with a long-term
 * solution here.
 */
let resourceChain = Promise.resolve();
let resourceChainLabel = undefined;
/**
 * Runs an asynchronous resource operation, possibly serializing it as
 * necessary.
 */
function runAsyncResourceOp(label, callback, serial) {
    // Serialize the invocation if necessary.
    if (serial === undefined) {
        serial = settings_1.serialize();
    }
    const resourceOp = rpc_1.suppressUnhandledGrpcRejections(debuggable_1.debuggablePromise(resourceChain.then(() => __awaiter(this, void 0, void 0, function* () {
        if (serial) {
            resourceChainLabel = label;
            log.debug(`Resource RPC serialization requested: ${label} is current`);
        }
        return callback();
    })), label + "-initial"));
    const finalOp = debuggable_1.debuggablePromise(resourceOp, label + "-final");
    // Set up another promise that propagates the error, if any, so that it triggers unhandled rejection logic.
    resourceOp.catch((err) => Promise.reject(err));
    // If serialization is requested, wait for the prior resource operation to finish before we proceed, serializing
    // them, and make this the current resource operation so that everybody piles up on it.
    if (serial) {
        resourceChain = finalOp;
        if (resourceChainLabel) {
            log.debug(`Resource RPC serialization requested: ${label} is behind ${resourceChainLabel}`);
        }
    }
}
//# sourceMappingURL=resource.js.map